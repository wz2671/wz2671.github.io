---
title: C++多线程编程
date: 2019-09-26 22:21:59
tags: 秋招笔记
---

[参考视频](https://b23.tv/av48611530/p5)


<!--more -->

***

# 看的博客
1. 并发执行带来的问题，死锁—是因为多个线程竞争资源而造成的僵局，进程无法向前推进。
2. 死锁产生的原因：系统资源的竞争，进程推进顺序非法，（信号量使用不当也会造成死锁，等待对方的资源）
3. 死锁产出的必要条件：互斥条件，不可剥夺条件，请求和保持条件，循环等待条件。
4. 避免死锁：加锁顺序；加锁时限；死锁检测。
5. 加锁顺序：指保证线程都是按照相同的顺序获得锁，那么死锁就不会发生。
6. 加锁时限：为尝试获取锁的时候加一个超时时间，如果超时就放弃对该锁的请求，并回退释放所有已经获得的锁，等待一段随机时间后再重试。（避免在同一时间出现很多竞争，当线程很多时，可能会同时竞争，同时超时。）
7. 死锁检测：当一个线程获得了锁，在线程或者锁相关的数据结构中将其记下，每当有线程请求锁，也需要记录在这个数据结构中。检测出来之后，就是释放所有的锁，回退等待一段时间后再重试，也可以设置优先级，优先级低的线程释放锁资源，优先级高的继续请求。

# C++锁``
https://www.jianshu.com/p/8c0ca5ba2338
1. 互斥锁： 指的是保证线程互斥访问一个信号量，避免多个线程同时访问同一内容而产生错乱。
2. 条件锁：条件锁
3. 自旋锁
4. 读写锁
5. 递归锁

# C++多线程编程

### 线程创建与启动
竞争资源可使用互斥量`mutex`，在头文件`include<mutex>`中，还有`std::mutex`来定义锁对象。

### 在C++11新标准库（可移植性）
* 线程启动、结束，创建线程步骤：
    * 包含头文件<thread>
    * 创建初始函数
    * `main`函数中创建线程并开始执行
        ```c++
        thread mytobj(myprint);
        mytobj.join();
        ```