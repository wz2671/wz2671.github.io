---
title: 《C++进阶心法》笔记
tags: CS笔记
date: 2019-10-20 17:23:59
---

[toc]


非常赞的一本书，讲述了C++的各种细节，对加深自己的理解非常有帮助。要是早日学习这本书，也不至于只能拿大大白菜价了。
⭐️⭐️⭐️⭐️⭐️
参考书籍：《C++进阶心法》；编著：吕吕、王琥；北京航空航天大学出版社

<!--more -->

-------

# 一. more C

### 1. 数组与指针
* 数组空间是静态分配的，编译时决定大小，数组名代表指针常量，不能修改。传参时，会自动退化为指针。
* **如果形参是数组的引用，数组的长度会作为类型的一部分**，例如：`int(&)[5]`和`int(&)[6]`是不同的数据类型。
* 指针和一维数组是相对应的，可以将多维数组当作一维数组看待，例如：`int d[3][4][5]`可强制转换为`int p[] = (int *)a`或`int p[][5] = (int(*)[5])a`。
* 字符数组空间分配在栈上，可以修改元素值；字符指针指向常量区字符串，不可修改元素值。

### 2. size_t
* 其大小是由生成的程序类型决定的（包括指针大小）
* CUP的位数由**字长**决定，字长表示CPU在同一时间内能够处理的二进制位数，由CPU中寄存器的位数决定（而不是数据总线的宽度）。

### 3. 文字常量和常变量
* 本质区别：文字常量在编译之后存储于代码段中，不可寻址，由操作系统保障；常变量存储于数据区（堆、栈、BSS段、数据段），可寻址，由编译器保障。例如：`int & r=5;`错误，`const int &r = 5;`正确（编译器先将文字常量转化为常变量）。
* 对于常变量，编译器会有一定的优化措施。如下例：

```c++  
//待验证
void show(const int& i)
{
    cout<< i <<endl;
}

int main()
{
    const int con2 = 4;
    int *ptr = NULL;
    ptr = const_cast<int *>(&con2);
    *ptr = 5;
    show(con2);     // 这句会输出5
    cout<<"con2: "<<con2<<endl;     // 这句会输出4
}
```


### 4. 数据类型扩展
* C语言中的扩展方法是，有符号类型的负数按符号位全补1。

### 5. 分离编译模式
* 所谓分离编译模式是指，将不同模块独立编译，生成独立的目标文件，然后在将目标文件组成最终的可执行文件。
* 声明：说一下即将调用的函数名，返回类型，参数类型；定义：给出函数的具体实现。
* 要点：
    1. 函数以及局部变量只能被定义一次，但可以被“声明”多次。
    2. 声明有自己的作用域。
    3. 函数若未被使用，只声明，不定义也无妨（编译链接不会出错）。

***

# 二、C++基础

### 1. 声明与定义

* 全局静态变量的作用域是当前源文件，不可以使用`extern`进行声明。
* 据说，类型的定义应该放在头文件中，但是，不能将函数和变量的定义放在头文件中，因为，**类型不具有外部连接特性，只具备内部连接特性，但函数和变量不是**。也就是说，在不同的源文件中，定义相同的类型（类）不会报错，但定义相同的变量或函数会报错。
* 必须初始化： 1.定义常变量；2.定义引用；3.类的常对象必须存在相应构造函数。
* 结构体初始化与赋值：

```c++
struct A
{
    int b;
    int c;
}
// 初始化
struct A a = {.b=1, .c=2}; //C99标准
struct A a = {b:1, c:2};  //可以指定初始化顺序和个数，扩展性好。

struct A a = {1, 2}; //顺序初始化，书写简约，灵活性较差。

A::A(int a, int b):b(a), c(b){}
struct A a(1, 2); // 使用构造函数初始化，不能再使用顺序和指定初始化。

//赋值
struct A a;
// a = {1, 2}; //写法有误
memset(&a, 0, sizeof(a));//使用memset置空
a.b=1; a.c=2;           //成员变量逐个赋值
struct A aa; aa = a;    //将已有的结构体变量进行赋值
```

### 2. sizeof
* `sizeof`的括号中可使用*对象*或者*类型*，但本质上都是判断类型大小。
* `sizeof`括号里的表达式不会执行，只会用来判断类型。
* 指针变量的位宽等于机器字长，机器字长由CPU寄存器的位数决定。
* 如果在`sizeof`括号中为函数调用，那么结果就是返回类型的大小。
* `sizeof`计算结构体和联合体会存在内存对齐原则。这部份说来复杂，只可意会。<font color=red>记忆要点: 首地址，偏移量，总大小</font>
* 还存在**位域结构体**，可以共用字节，节约存储空间。
* `sizeof`计算数组时，也要区分数组的类型。如下例：

```c++
int a[3][5];
sizeof(a); // =60
sizeof(a[4]); // =20
sizeof(a[0][0]); // = 4

double * (*d)[3][6];
sizeof(d); // =4
sizeof(*d); // = sizeof(double *[3][6]) = 3*6*sizeof(double *) = 3*6*4
sizeof(**d); // = sizeof(double *[6]) = 6*sizeof(double *)
sizeof(***d); // = sizeof(double *) = 4
sizeof(****d); // = sizeof(double) = 8
```

### 3. const
* `const`和指针混用时比较复杂。
* `const`和数据类型搭配时形成“常类型”，可以放在类型前面或者后面，例如`const int i`和`int const i`是等价且合法的。但是，一定出现在变量之前。
* 注意**指针常量**和**常量指针**；
    * `int const * p`：指针常量是指*指针的值不可修改*
    * `int * const p`：常量指针是指*指针指向的值不可修改*
* `const`还可以配合二重指针使用。
    * `int const ** p1`：`p1`是一个正常指针，指向的变量类型是`int const *`（常量指针）；
    * `int * const * p2`：`p2`也是个正常指针，只想的变量类型是`int * const`（指针常量）；
* `const`成员函数可以和非常函数构成重载，**常对象**只能调用常成员函数。
* 对于按值传递的参数或返回值，使用`const`修饰并没有任何意义，因为对临时变量的修改对原始值没有任何影响。
* `const_cast`可以去除目标的`const`或着`volatile`属性，它取消的是间接引用时的改写权限，并不能修改变量本身的`const`属性。

### 待补充

### 4. 引用
* 引用的底层实现本质上是**指针常量**，可以通过反汇编观察到对应的底层实现。引用本质上也是一个变量，并且有自己的内存空间，不仅功能上等价于指针常量，实现上也是如此。常量的实现在C++中是通过保存在*符号表*中。
* 在高层语言中，它也是占用4字节的空间（因为是指针），和指针常量最大的区别是，指针常量允许寻址(指针的地址)，但是引用不允许（它的地址只允许编译器所有）。
* 数组元素可以是指针常量，但不允许是引用。
* 可以通过一些骚操作来获取引用的地址，间接修改引用指向的对象，但是该行为是比较诡异的。
* 在debug模式下，整形变量前后会在前后添加4字节的调试信息，一个变量占12字节。

### 5. 链式操作
* 要实现链式操作，返回值不能为空（因为链式操作本质上是返回的对象再继续调用成员函数，而`void`类型不能参与任何类型的运算）。
* 如果按值返回，那么在函数返回时，会调用类的拷贝构造函数，这样不但有较大的运行开销，还要求我们编写正确的拷贝构造函数。
* 实现输入/输出的链式操作必须要返回引用，否则无法完成。

### 6. C++数据类型
* 在C++中数据类型分为*基本数据类型*和*复合数据类型或构造数据类型*。
* 基本数据类型时C++内部预定义的，也称为`built-in`数据类型。
* 两者的主要区别在于**构造数据类型的实例**称为对象，是属性和方法的集合，而基本数据类型的实例叫做变量，无成员函数。
* 隐式类型转换：
    * 算术运算式（低类型自动转换为高类型）。
    * 赋值表达式（右边表达式自动隐式转换为左边变量的类型）。
    * 函数调用传递参数（将实参自动转换为形参）。
    * 函数返回（将返回表达式类型转换为返回值类型）。
* 显式类型转换：
    * 也就是强制类型转换，有两种写法。
    * `(T)expression //c-style cast` 将目标数据类型放置圆括号中。
    * `T(expression) //function-style cast` 将目标数据类型当作一个函数使用。
* 新式类型转换：
    * 主要有四种：`const_cast`，`static_cast`，`dynamic_cast`，`reinterpret_cast`。统一的语法格式为：`type_cast_operator<type> (expression)`。
    * `const_cast`需要注意并不会改变变量本身的`const`和`volatile`属性。取消的是对间接引用（指针和引用）的改写限制。
    * `static_cast`需要注意转换时语法形式的括号不能省略。只能进行一些相关类型之间的合理转换，它进行的是一种静态转换，是在编译时转换的，空间时间效率本质上等价于C的强制类型转换。
    * `dynamic_cast`只能用于引用或指针之间的转换，而且被引用的对象必须拥有虚成员函数。还可以用于交叉转换（在多重继承的情况下）。
* 其他类型转换：
    * 类的单参数构造函数可以充当类型转换函数。`Team(const Student &s){};`
    * 可以定义成员函数`operator int(){}`来为类对象提供转换为基本数据类型的转换函数。
* 数值类型与`string`的相互转换：
    * 数值类型转换为`string`类型
        1. 使用函数模板+`ostringstream`可以将基本数据类型转换成`string`
        2. 可以使用标准库函数`std::to_string()`。
    * `string`类型转换为数值类型
        3. 使用函数模板+`istringstream`。
        4. 使用标准库函数`atoi, strtoul, atoll, strtoull, atof, strtold`
* 临时变量不能作为非`const`引用实参，并不是说临时变量为常量，而是编译起为了防止我们的非常规行为导致错误。

### 7. 左值、右值和常引用
* 非左值作为实参时，形参如果是一般引用，就会编译出错，必须要声明为常引用。
* 所有可以出现在赋值运算左边的表达式都是左值，指的是**可寻址的非只读表达式**。（如果表达式的运算结果是由文字常量生成的临时无名对象，则不能作为左值，包括数值常量，字符常量，符号常量。类临时对象可以作为左值）。
* 对非左值建立常引用的两个条件：1. 表达式的结果可以寻址（文字常量不可寻址）。2. 结果的数据类型和引用的数据类型一致。（如果不一致，会先另外创建一个无名变量，将表达式结果存入，然后在建立对该无名变量的常引用）。
* 一般的引用（非 常引用）只能建立在相同数据类型的变量上，而常引用，可以先创建临时变量再绑定常引用。
* 无名临时变量虽然具有常量性，但是有些是可以作为左值的（例如类的临时变量对象）。

### 8. mutable
* `mutable`和`const`相反，永远是可变的。
* 作用：1. 可以保证大部分成员变量是“只读”而少部分变量可修改。2. 使`const`函数可以修改成员变量。
* 注意：1. 不可以修饰静态变量或常量成员函数。2. 在一个类中，尽量或者不使用。
* 使用：例如我们有一个常对象，可以对它的`mutable`成员变量进行修改。 

### 9. 命名空间
* C++标识符作用域：局部作用域（代码块）、函数作用域、类域、命名空间域、全局作用域。
* 命名空间的作用就是减少命名冲突情况。
* 命名空间和`static`搭配使用挺复杂的。总之，`static`变量不具有外部链接性，可以有效降低耦合程度。

### 10. 头文件
的作用如下：
* 加强类型检查，提高类型安全性。
* 减少共用代码的重复书写，提高编程效率。
* 提供保密和代码重用的手段。

***

# 三、内存管理

### 1. 程序的内存布局

| 段名 | 存储内容 | 分配方式 | 生长方向 | 读/写特点 | 运行态 |
| --- | --- | --- | --- | --- | --- |
|  代码段 (text segment) | 程序指令、字符串常量、虚函数表 | 静态分配 | 由低到高 | 只读 | 用户态 | 
|  初始化数据段 (data segment) | 全局变量或静态变量 | 静态分配 |  由低到高 | 可读可写 | 用户态 |
|  未初始化数据段 (BSS segment) | 全局变量或静态变量 | 静态分配 |  由低到高 | 可读可写 | 用户态 |
|  堆 (heap) | 动态申请的数据 | 动态分配 | 由低到高 | 可读可写 | | 用户态 |
|  映射段 (memory mapping segment) | 动态链接库、共享文件、匿名映射对象 | 动态分配 | 由低到高 | 可读可写 | 用户态 |
|  栈 (stack) | 局部变量、函数参数和返回值、函数返回地址、调用者环境信息 | 动态+静态 | 由高到低 | 可读可写 | 用户态 |
|  内核空间 (kernel space) | 操作系统、驱动程序 | 动态+静态 | 由低到高+由高到低 | 不能直接访问 | 内核态 |

* 调用函数时，断点保存，入栈顺序（出栈顺序相反）：
    1. 主函数的下一条语句的地址（扩展指针寄存器的内存`eip`）
    2. 当前栈帧的底部地址（扩展基址指针寄存器的内容`ebp`）
    3. 被调用函数的实参（一般时从右往左的顺序）
    4. 调用函数的局部变量

* `new`有三种表现形式：
    * `new operator`是C++的关键字，它完成的功能是调用下面的两个函数。
    * `operator new()`用于申请`heap`上的空间，功能类似于`malloc()`（实际上也是对它的封装）。
    * `placement new()`用于在已获得的堆空间上调用类构造函数来初始化对象。它是`operator new()`的重载，在参数列表中多了一个指针指向已申请空间。
* `delete`也有相应的`delete operator`，`operator delete()`，`placement delete()`。
* 构造函数中的`new/new[]`与析构函数中的`delete/delete[]`需要一一对应。

### 2. 智能指针
* 主要作用是用栈只能指针离开作用域自动销毁时调用析构函数来释放资源。提供的功能有：
    * 以指针的行为方式访问所管理的对象，需要重载指针`->`操作。
    * 解引用（`dereferencing`），获取所管理的对象，需要重载解引用`*`操作符。
    * 智能指针在其声明周期结束时自动销毁其管理的对象。
    * 引用计数、写时复制、赋值即释放对象拥有权限和控制权限转移。
* 引用计数的目的：
    * 节省内存，提高程序运行效率。
    * 记录引用对象的所有者数量，在引用计数为0时，让对象的最后一个拥有者释放对象。
    * 策略时利用一个辅助类来说管理指针的复制，辅助类的数据成员是一个计数器和一个指针。
* 智能指针是`RAII(Resource Acquisition is Initialization)`技术的一种实现，也就是“资源获取即初始化”，由C++之父Bjarne Stroustrup提出，意为在构造函数中获取资源，在析构函数中释放资源。

***

# 四、函数

### 3. `main()`函数：
    
```c++
int main();
int main(int argc, char * argv[])
int main(int argc, char ** argv)
```
* `argc`代表参数的个数，`argv`数组中的每一个元素用于保存命令行参数的内容。
* windows平台可通过环境变量`errorlevel`获取`main()`函数的返回值。

    ```c++
    main.exe
    if % errorlevel % == 3 echo third
    if % errorlevel % == 2 echo second
    if % errorlevel % == 1 echo first
    ```
* 所有的外部对象的构造函数都是先于`main()`函数执行的。包括这些对象的成员变量所需调用的函数等。

### 4. 函数参数入栈方式与调用约定
* “调用约定”就是指明了向被调用函数传递参数的实现方式。C/C++常见的调用规范有`__cdecl`、`__stdcall`、`__fastcall`、`__thiscall`。
* 参数的入栈顺序是从右往左。过分追求小技巧，容易给程序带来缺陷，例如`cout<< ++i << --i << i++;`，在该表达式的链式操作中，各表达式的入栈顺序还是从右往左的。
* 函数调用时的返回地址、参数、函数内的局部变量、表达式运算时产生的无名变量等都是存储在栈上的。

### 5. 拷贝构造函数
* `A(const A&){}`参数必须是引用，如果不是引用，会导致无穷递归问题。
* 通常情况下是`const`的，但不是必须的。
* 在以下情况下会调用拷贝构造函数：
    * 显式或隐式地用同类型的一个对象来初始化另一个对象。
    * 作为实参以值传递的方式传递给另一个函数。
    * 在函数体内返回一个对象也会调用返回值类型的拷贝构造函数。
    * 需要产生一个临时类对象时。

### 6. 函数指针

```c++
#include <iostream>
using namespace std;
int add(int i, int j)
{
    return i+j;
}

int main()
{
    //用法一
    int (* addP)(int, int) = add;
    int tmp = addP(2, 3);
    //用法二
    int (* addP)(int, int) = &add;
    int tmp = (*addP)(2, 3);
    //用法三
    typedef int(* AddP)(int, int);
    AddP funcP = add;
    tmp = funcP(2, 3);
}
```