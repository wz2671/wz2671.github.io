---
title: C/C++笔记
tags: 笔记
---

参考《C和C++程序员面试秘籍》、牛客网、《C++沉思录》、《More Effective C++》

<!--more -->


## C
1. 宏定义
    加括号，不加分号
2. 预定义
3. 智能指针
主要是针对内存泄漏问题，利用生命周期结束时，类会自动调用析构函数，让智能指针类自动释放内存。
常用的有shared_ptr, unique_ptr, weak_ptr, auto_ptr。
unique_ptr独占指针，不能赋值，不能和其他指针指向同一对象，可以使用move函数移交权限。
shared_ptr可以多个智能指向同一个对象，会对引用个数进行技术，当计数为0时会自动释放内存，但可能出现循环引用的情况。
weak_ptr针对循环引用问题，不管理内存，不改变计数，访问对象时需要转换成shared_ptr。
auto_ptr赋值不报错，会崩溃。

4. 引用和指针
引用必须被初始化为一个已有对象，它是变量的一个别名，和原始的变量指的同一块内存区域，应避免函数返回引用，无论是否是new的内存。流操作符应返回引用或指针。
指针本身就是一个变量，存储着内存区域的地址。
引用不可以指向空，指针可以为空。引用效率更高，不用测试其有效性。
指针可以被重新赋值，引用总是代表原始对象。对指针赋值不会改变原始值。
**引用使用**: 当指向某个东西并且不会再改变时，当实现一个操作符且语法需求无法用指针满足。

5. cast类型转换
常用的有四种，static_cast, dynamic_cast, const_cast, reinterpret_cast.
static_cast用的较多，可以转换各种类型，继承中向下转换不安全。（和C旧式转型有相同的威力和意义）
dynamic_cast动态转换，适用于含有虚函数的转换，用于类层次的转换.(将指向基类的指针或引用转换为指向子类的对象的)
const_cast 改变的是某事物的常量性或变易性(volatileness)。

6. allocator类
可以在不调用构造函数的情况下，预先申请内存块，只需要指定类型和对象个数即可。allocate(deallocate), construct(destroy)。
释放内存前要先调用destroy.可以根据自己的需求，自由构建对象。
内存分配分为两种，对应的系统调用为brk和mmap。

7. 模板类

8. 结构体: 默认的继承方式是公有（而class默认的继承方式是私有）

9. 内存对齐：
 * 规则1：第一个成员从0开始，以后每个数据成员的偏移量必须是min(#pragma pack(), 这个数据成员的自身长度)的倍数。
 * 规则2：数据内成员对齐完毕后，结构体本身也要对齐，按照min(#pragma pack(), 最大数据成员长度)对齐。


***
## C++

### 1. 面向对象
* struct 与 class的区别
    c语言中struct是没有成员函数的。c++中struct中默认都是公有的（公有继承，公有成员变量等）。
	
* 使用不带参数的构造函数构造对象时，不用加括号。

* 初始化列表的初始化顺序与变量声明的顺序一致。

* 初始化列表必用：const和reference类型成员变量，父类的private成员变量。

* 普通构造函数能够被隐式调用，而explicit构造函数只能被显示调用。

* 基类的析构函数应为virtual。
	不然可能会产生内存泄漏。（当父类指针指向子类对象时，不含虚指针会是指针调用父类的析构函数，无法释放子类空间）

	* 复制构造函数要深拷贝，形式为`Test(const Test &test){}`,会在三种情况调用：1.`void fun(Test test){}`；2.`Test fun(){return Test t}`；3.`Test t2 = t1`。

* 复制构造函数和赋值函数(`Test & operator = (const Test &test)`)的区别: 复制构造函数会创建新对象新内存。赋值函数是引用对象。赋值函数要释放内存，检查是否同一对象。

* `String`类的编程实现（运算符重载）。

* 多态和指针运算（对象数组）不应当混用，不同指针指向的size不一样。

***

### 2. 继承和多态
* 私有继承：编译器不会将派生类对象转换成基类对象。建议用组合，不用私有继承。

* 虚继承：可以有效避免多重继承的二义性，只会调用一次父类的构造函数。

* 虚函数实现：
如果一个类含有虚函数，操作系统会为这个类分配一个指针成员指向一个虚函数表（VTBL），每一项指向一个虚函数的地址（函数指针的数组）。
每个类有自己的虚函数表，子类会覆盖父类的虚函数表项，虚函数表里内容是函数指针，指向代码段中函数的地址，每个对象有指向虚函数表的指针，它会动态地决定具体指向哪个虚函数表。

* 在编译期间无法确定指针指向的是基类对象还是派生类对象，但编译后的调用代码能够根据具体对象获取正确的VTBL，调用正确的虚函数。

***

### 3. 内存
* malloc原理：
分为两种情况，*一种*是分配的内存小于128K，直接在堆区中进行分配，对应的系统调用是brk。
堆区也只有在初次调用malloc函数时，操作系统才会进行分配。一般是从低地址位向高地址位增长。
其中堆区内存是由大小不一的内存块通过隐式链表链接的，结构体mm_struct中记录着内存块的结束和开始位置。
分配时通过遍历空闲内存块获取最合适的内存块进行分配。
*另一种*是在分配的内存大于128K时，这时候会在文件映射区进行分配。对应的系统调用是mmap。
它在内存中的位置一般间于堆区和栈区，该区会建立一个磁盘到内存映射，这也是虚拟内存的一种实现方式。
除此之外文件映射区中一般还存储着动态链接库。

* C++内存块分为6个部分
数据段，代码段，BSS段，堆区，栈区，文件映射区。
数据段，存储着静态变量和全局变量。
代码段，存储着二进制机器码
BSS，存储着未初始化或者值为零的全局变量或静态变量。
栈区，存储着局部变量，函数参数，返回地址，返回值等。

* 内存泄漏
C++在对象被产生时，会自动调用构造函数，构造函数本身也会配有资源(有成员也是对象，对象有自己的资源)。