---
title: mongo学习笔记
date: 2021-08-07 12:08:27
tags: [服务端开发, 数据库]
---

参考书籍：  
[MongoDB实战](/doc/MongoDB实战.pdf) 这本书是一本快速上手的手册，简单，直接，内容全面。  
[MongoDB权威指南](https://gitee.com/kadys/developer-books-01/raw/master/MongoDB/MongoDB%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97.pdf)  
[深入学习MongoDB](https://gitee.com/kadys/developer-books-01/raw/master/MongoDB/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0MongoDB.pdf) 包含两部分：MongoDB扩展技术和MongoDB开发技巧50例，前者主要是介绍如何部署分布式的数据库，后者介绍了开发中种种需要注意的地方

每本书的只有一百页左右，太棒惹。

![封面](/images/mongodb.png)


# MongoDB开发技巧50例

### 1. 一致性和速度折中

* 针对的问题是，多个文档关联时，是使用冗余（反范式化）的方式还是使用引用（范式化）的方式存储。
* 例如，有订单里有商品的信息，商品有单独的集合，那么订单中应该存储商品的id，还是商品的数据？
    ```json
    // 商品
    {
        "_id": productId,
        "name": name,
        "price": price,
        "desc": description
    }
    // 订单
    {
        "_id": orderId,
        "user": userInfo,
        "items": [
            productId1,     // 是存储商品id还是完整的数据条目
            productId2,
            productId3,
        ],
    }
    ```
* 如果采用范式化，每次读订单信息的时候，都需要额外再读取商品信息。
* 如果采用反范式化，那么可能会有不一致的情况。
* 实践中，商品的信息改变频率很低，且不必更新到所有订单，因此最佳选择是将订单反范式化（就存完整的商品信息）

* **范式化可使数据可用性更长久**

### 2. 尽量单个查询获取数据

* 尽量将需要一块获取的数据存到一起，这样可以一次查询。
* 如果要获取多条数据，也尽量就返回多条数据，避免多次查询。
* 如果某些信息只在一个文档中使用，就应该嵌入这个文档
* 只有一个键或一个值的也应嵌入

### 3. 不要嵌入不断增加的数据

* 对数据追加数据很低效，正常使用中数据和对象大小应当相对固定
* 会不断增加的数据，作为单独的文档处理比较合适

### 4. 预先分配空间
* 如果知道未来要用到那些字段和数据，可以预先填充数据，更新值比插入值快的多
* 如果确定未来文档的大小，可以先用辣鸡数据填充，再重置字段，可以预分配足够的空间

### 5. 数组和子文档存储权衡
(TODO: 补充例子)
* 如果想无需标识符就获取某项的信息，就要用数组存储
* 如果明确知道查讯的属性，就可以采用文档存储

### 6. MongoDB应只存取数据
(TODO: 补充例子)
* 尽量通过优化文档结构，使得信息可以直接从文档中获得，避免让MongoDB使用JavaScript计算
* 如果在更新文档时，不确定某些字段是否需要更改，可以用两种修改：
    1. 硬改，让后台任务或客户端校验修复不一致的情况
    2. 使用`findAndModify`锁住文档直至修改完毕

### 7. `$where`理解
* 可以在查询中使用`$where`自子句来执行JavaScript代码。灵活但低效
    ```js
    > db.members.find({"$where": function() {
        return this.member[0].age == this.member[1].age;
    }})
    ```
* 使用普通查询会转换成`BSON`格式与MongoDB中进行数据对比。使用`$where`会将文档转为js对象并执行对应脚本
* 使用`$where`时可以通过条件减少要匹配的文档，以减少性能消耗。

### 8. 数据问题
* 系统奔溃，MongoDB更新可能会导致数据不一致
* 可以通过建立`cron`任务进行修复
    * 一致性修复器：核对计算，检查重复数据，确保数据一致性
    * 预分配器：创建今后要用到的文档
    * 聚合器：更新文档内部的聚合数据，使之为最新数据
    * 结构校验器：确保当前所有的文档都有指定的字段，否则就自动校正或发送通知。
    * 备份任务：定期对数据库做`fsync`，加锁和到处操作

### 9. 用正确的类型存放数据
* 数字：`AND`和`OR`操作只适用于整数，不能是双精度浮点数。数据库会自动转化溢出的32位浮点数，将其变成64位的。
* 日期：是**精确**的日期就要存成日期的类型，不精确的可以存成`yyyy-mm-dd`形式的字符串ISO格式的日期。
* 字符串：都是utf-8编码的，或者以二进制形式存储
* `ObjectId`：<font color=red> 就以`ObjectId`存储，不要存成字符串 </font>。
    * 字符串无法与`ObejctId`相匹配，方便查询
    * `ObjectId`中包含文档的创建日期等，（听一个分享说是：[创建时间 : 主机号 : 进程号 : 序号]）
    * 字符串要比`ObjectId`多占用两倍空间
* 如果数据本身具有唯一的字段，可用来做_id，但是要**确保其唯一性**，要留意**索引的树结构，保证插入顺序是有序的**
* 不要用文档作为`_id`，以下是书中的说明，（然而并没有很懂：
    > 除了不可避免地情况（如MapReduce）地输出，通常都不应该将文档作为`_id`。问题就在于索引一个文档中的字段和索引文档完全不一样，如果没有每次查询整个子文档的计划，最后会有多个索引，如`_id`，`_id.foo`，`_id.bar`等。
    更改`_id`必须得覆盖整个文档，所以若子文档的字段有变化则更新非常不便。

### 10. 不要用数据库引用
* 数据库引用如下，它表示该文档引用了`dbName`数据库中`dcollectionName`集合的`identifier`文档。
    ```js
    {$id: identifier, $ref: collectionName, $db: dbName}
    ```
* 它仅仅是一个普普通通的子文档，并没有什么神奇之处，依旧要进行一次额外的查询。
* 例如系统中的用户可以系统中的任意一件事情，可以通过数据库引用来存储对应的集合。

### 11. 不要使用`GridFS`处理小的二进制数据
* 查询`GridFS`需要查询两次，一次获取文件的元信息，另一次获取其内容。
* 它是用来将大的二进制对象切成小片存放到数据库中的。

### 12. 处理故障
* MongoDB在进行无缝的故障切换时，可能会抛出网络错误和异常，需要用户自行处理
* 主节点异常时，可能会出现各种错误，此时也需要多多注意各种问题的处理

### 13. 优化
* 尽量减少磁盘访问
* 使用索引减少内存占用
* 如果要大约返回集合的一半数据的时候，就不要使用索引了。
* 每次插入删除文档时，需要同步更新索引，因此索引会增加很多额外的写入。

### 14. 索引使用
* 如果索引覆盖了整个查询的字段，那么这种查询会直接用索引的数据返回结果，不再访问文档;  
    例如当前有如下索引：`db.foo.ensureIndex({"x": 1, "y": 1, "z": 1})`，在进行查询`db.foo.find({"x": criteria, "y": criteria}, {"x: 1, "y": 1, "z": 1, "_id": 0})`查询时，会之访问索引的数据，不访问整个集合的数据
* 尽量建立能被多个查询利用的复合索引。只要索引开头部分匹配就能利用索引。

### 15: 文档和查询的设计
* 如果属性平铺在了整个文档中时，查询时会不得不遍历每个字段，内嵌文档可以减少字段的访问。
* `AND`类型的查询，尽量先将过滤条件严格的放在前面，这样后面的查询搜索空间就小了很多。
* `OR`类型的查询，和上面的相反，应将匹配结果较多的放在界面，这样后续的查询搜索空间会少很多

### 16. 数据安全性和一致性
* 单机做日志，多机则复制，或者两者兼用
* 数据库崩溃了，并且没有日志，运行`repair`的修复时有限甚至无法修复的，比较推荐的做法时从备份快速回复，或者从头开始同步。**但一定要清除所有损坏的数据**
* 对于某些重要的操作，可以通过设置`w`发送`getlasterror`到服务器等待`w-1`个节点完成才当作写入成功；如`db.runCommand({"getlasterror": 1, "w": num， "wtimeout": 100})`来保证数据的安全性。同时一定要给`w`设置超时。
* `fsync`选项可以保证日志中有记录，但会让应用程序暂停直至写入磁盘，会特别影响性能，而且绝不要在未开启日志时使用`fsync`。
* 在有日志的情况下，数据库奔溃后重启时，会自动修复数据才开始接受连接，但比repair节省很多时间，日志千万不要删除。
* 备份文件时，使用`fsync`和锁配合，然后到处数据，不能没有执行`fsync`和上锁就直接复制所有文件，可能会损坏数据文件。

### 17. 管理技巧
* 手动清理块集合，也就是`GridFs`文件。
* 不要改变复制组成员投票的权值。
* 无活跃节点时可重置复制组
* 不必指定`--shardsvr`和`--configsvr`参数
    * `--configsvr`会默认更改端口为`27019`和开启`diaglog`
    * `--shardsvr`会将端口默认修改为`27019`
* 开发时使用`--notablescan`会在查询做全表扫描时返回错误，只能使用索引进行查询
* 在shell中管理所有服务器和数据库，它可以连各个服务器，一个shell管理所有的。
* 创建启动文件，也就是写个js文件，启动时执行好了
* 自定义全局函数  
    例如添加一个`getOplogLength`的函数到数据库类中，那么可以在初始化之前执行：
    ```js
    DB.prototype.getOplogLength = function() {
        var local = this.getSisterDB("local");
        var first = local.oplog.rs.find().sort({$natural: 1}).limit(1).next();
        var last = local.oplog.rs.find().sort({$natural: -1}).limit(1).next();
        print("total time: " + (last.ts.t - first.ts.t) + " secs");
    };
    ```
    对于已经在使用的数据库，就需要逐个添加属性到实例对象里
* 使用单个连接读取自身写入，这样可以保证写入和读取的顺序一直。

### 18. 学习JavaScript
* 推荐了《JavaScript语言精粹》
