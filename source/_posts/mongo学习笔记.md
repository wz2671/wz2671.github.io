---
title: mongo学习笔记
date: 2021-08-07 12:08:27
tags: [服务端开发, 数据库]
---

参考书籍：  
[MongoDB实战](/doc/MongoDB实战.pdf) 这本书是一本快速上手的手册，简单，直接，内容全面。  
[MongoDB权威指南](https://gitee.com/kadys/developer-books-01/raw/master/MongoDB/MongoDB%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97.pdf)  
[深入学习MongoDB](https://gitee.com/kadys/developer-books-01/raw/master/MongoDB/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0MongoDB.pdf) 包含两部分：MongoDB扩展技术和MongoDB开发技巧50例，前者主要是介绍如何部署分布式的数据库，后者介绍了开发中种种需要注意的地方

每本书的只有一百页左右，太棒惹。

![封面](/images/cover/mongodb.png)


<!--more -->

# MongoDB开发技巧50例

### 1. 一致性和速度折中

* 针对的问题是，多个文档关联时，是使用冗余（反范式化）的方式还是使用引用（范式化）的方式存储。
* 例如，有订单里有商品的信息，商品有单独的集合，那么订单中应该存储商品的id，还是商品的数据？
    ```json
    // 商品
    {
        "_id": productId,
        "name": name,
        "price": price,
        "desc": description
    }
    // 订单
    {
        "_id": orderId,
        "user": userInfo,
        "items": [
            productId1,     // 是存储商品id还是完整的数据条目
            productId2,
            productId3,
        ],
    }
    ```
* 如果采用范式化，每次读订单信息的时候，都需要额外再读取商品信息。
* 如果采用反范式化，那么可能会有不一致的情况。
* 实践中，商品的信息改变频率很低，且不必更新到所有订单，因此最佳选择是将订单反范式化（就存完整的商品信息）

* **范式化可使数据可用性更长久**

### 2. 尽量单个查询获取数据

* 尽量将需要一块获取的数据存到一起，这样可以一次查询。
* 如果要获取多条数据，也尽量就返回多条数据，避免多次查询。
* 如果某些信息只在一个文档中使用，就应该嵌入这个文档
* 只有一个键或一个值的也应嵌入

### 3. 不要嵌入不断增加的数据

* 对数据追加数据很低效，正常使用中数据和对象大小应当相对固定
* 会不断增加的数据，作为单独的文档处理比较合适

### 4. 预先分配空间
* 如果知道未来要用到那些字段和数据，可以预先填充数据，更新值比插入值快的多
* 如果确定未来文档的大小，可以先用辣鸡数据填充，再重置字段，可以预分配足够的空间

### 5. 数组和子文档存储权衡
(TODO: 补充例子)
* 如果想无需标识符就获取某项的信息，就要用数组存储
* 如果明确知道查讯的属性，就可以采用文档存储

### 6. MongoDB应只存取数据
(TODO: 补充例子)
* 尽量通过优化文档结构，使得信息可以直接从文档中获得，避免让MongoDB使用JavaScript计算
* 如果在更新文档时，不确定某些字段是否需要更改，可以用两种修改：
    1. 硬改，让后台任务或客户端校验修复不一致的情况
    2. 使用`findAndModify`锁住文档直至修改完毕

### 7. `$where`理解
* 可以在查询中使用`$where`自子句来执行JavaScript代码。灵活但低效
    ```js
    > db.members.find({"$where": function() {
        return this.member[0].age == this.member[1].age;
    }})
    ```
* 使用普通查询会转换成`BSON`格式与MongoDB中进行数据对比。使用`$where`会将文档转为js对象并执行对应脚本
* 使用`$where`时可以通过条件减少要匹配的文档，以减少性能消耗。

### 8. 数据问题
* 系统奔溃，MongoDB更新可能会导致数据不一致
* 可以通过建立`cron`任务进行修复
    * 一致性修复器：核对计算，检查重复数据，确保数据一致性
    * 预分配器：创建今后要用到的文档
    * 聚合器：更新文档内部的聚合数据，使之为最新数据
    * 结构校验器：确保当前所有的文档都有指定的字段，否则就自动校正或发送通知。
    * 备份任务：定期对数据库做`fsync`，加锁和到处操作

### 9. 用正确的类型存放数据
* 数字：`AND`和`OR`操作只适用于整数，不能是双精度浮点数。数据库会自动转化溢出的32位浮点数，将其变成64位的。
* 日期：是**精确**的日期就要存成日期的类型，不精确的可以存成`yyyy-mm-dd`形式的字符串ISO格式的日期。
* 字符串：都是utf-8编码的，或者以二进制形式存储
* `ObjectId`：<font color=red> 就以`ObjectId`存储，不要存成字符串 </font>。
    * 字符串无法与`ObejctId`相匹配，方便查询
    * `ObjectId`中包含文档的创建日期等，（听一个分享说是：[创建时间 : 主机号 : 进程号 : 序号]）
    * 字符串要比`ObjectId`多占用两倍空间
* 如果数据本身具有唯一的字段，可用来做_id，但是要**确保其唯一性**，要留意**索引的树结构，保证插入顺序是有序的**
* 不要用文档作为`_id`，以下是书中的说明，（然而并没有很懂：
    > 除了不可避免地情况（如MapReduce）地输出，通常都不应该将文档作为`_id`。问题就在于索引一个文档中的字段和索引文档完全不一样，如果没有每次查询整个子文档的计划，最后会有多个索引，如`_id`，`_id.foo`，`_id.bar`等。
    更改`_id`必须得覆盖整个文档，所以若子文档的字段有变化则更新非常不便。

### 10. 不要用数据库引用
* 数据库引用如下，它表示该文档引用了`dbName`数据库中`dcollectionName`集合的`identifier`文档。
    ```js
    {$id: identifier, $ref: collectionName, $db: dbName}
    ```
* 它仅仅是一个普普通通的子文档，并没有什么神奇之处，依旧要进行一次额外的查询。
* 例如系统中的用户可以系统中的任意一件事情，可以通过数据库引用来存储对应的集合。

### 11. 不要使用`GridFS`处理小的二进制数据
* 查询`GridFS`需要查询两次，一次获取文件的元信息，另一次获取其内容。
* 它是用来将大的二进制对象切成小片存放到数据库中的。

### 12. 处理故障
* MongoDB在进行无缝的故障切换时，可能会抛出网络错误和异常，需要用户自行处理
* 主节点异常时，可能会出现各种错误，此时也需要多多注意各种问题的处理

### 13. 优化
* 尽量减少磁盘访问
* 使用索引减少内存占用
* 如果要大约返回集合的一半数据的时候，就不要使用索引了。
* 每次插入删除文档时，需要同步更新索引，因此索引会增加很多额外的写入。

### 14. 索引使用
* 如果索引覆盖了整个查询的字段，那么这种查询会直接用索引的数据返回结果，不再访问文档;  
    例如当前有如下索引：`db.foo.ensureIndex({"x": 1, "y": 1, "z": 1})`，在进行查询`db.foo.find({"x": criteria, "y": criteria}, {"x: 1, "y": 1, "z": 1, "_id": 0})`查询时，会之访问索引的数据，不访问整个集合的数据
* 尽量建立能被多个查询利用的复合索引。只要索引开头部分匹配就能利用索引。

### 15: 文档和查询的设计
* 如果属性平铺在了整个文档中时，查询时会不得不遍历每个字段，内嵌文档可以减少字段的访问。
* `AND`类型的查询，尽量先将过滤条件严格的放在前面，这样后面的查询搜索空间就小了很多。
* `OR`类型的查询，和上面的相反，应将匹配结果较多的放在界面，这样后续的查询搜索空间会少很多

### 16. 数据安全性和一致性
* 单机做日志，多机则复制，或者两者兼用
* 数据库崩溃了，并且没有日志，运行`repair`的修复时有限甚至无法修复的，比较推荐的做法时从备份快速回复，或者从头开始同步。**但一定要清除所有损坏的数据**
* 对于某些重要的操作，可以通过设置`w`发送`getlasterror`到服务器等待`w-1`个节点完成才当作写入成功；如`db.runCommand({"getlasterror": 1, "w": num， "wtimeout": 100})`来保证数据的安全性。同时一定要给`w`设置超时。
* `fsync`选项可以保证日志中有记录，但会让应用程序暂停直至写入磁盘，会特别影响性能，而且绝不要在未开启日志时使用`fsync`。
* 在有日志的情况下，数据库奔溃后重启时，会自动修复数据才开始接受连接，但比repair节省很多时间，日志千万不要删除。
* 备份文件时，使用`fsync`和锁配合，然后到处数据，不能没有执行`fsync`和上锁就直接复制所有文件，可能会损坏数据文件。

### 17. 管理技巧
* 手动清理块集合，也就是`GridFs`文件。
* 不要改变复制组成员投票的权值。
* 无活跃节点时可重置复制组
* 不必指定`--shardsvr`和`--configsvr`参数
    * `--configsvr`会默认更改端口为`27019`和开启`diaglog`
    * `--shardsvr`会将端口默认修改为`27019`
* 开发时使用`--notablescan`会在查询做全表扫描时返回错误，只能使用索引进行查询
* 在shell中管理所有服务器和数据库，它可以连各个服务器，一个shell管理所有的。
* 创建启动文件，也就是写个js文件，启动时执行好了
* 自定义全局函数  
    例如添加一个`getOplogLength`的函数到数据库类中，那么可以在初始化之前执行：
    ```js
    DB.prototype.getOplogLength = function() {
        var local = this.getSisterDB("local");
        var first = local.oplog.rs.find().sort({$natural: 1}).limit(1).next();
        var last = local.oplog.rs.find().sort({$natural: -1}).limit(1).next();
        print("total time: " + (last.ts.t - first.ts.t) + " secs");
    };
    ```
    对于已经在使用的数据库，就需要逐个添加属性到实例对象里
* 使用单个连接读取自身写入，这样可以保证写入和读取的顺序一直。

### 18. 学习JavaScript
* 推荐了《JavaScript语言精粹》


*** 

# MongoDB权威指南

### 1. 数据类型

* MongoDB支持如下的数据类型：
    null, 布尔，32位整数，64位整数，64位浮点数，字符串，符号，对象id，日期，正则表达式，js代码，二进制数据，最大值，最小值，未定义，数组，内嵌文档。
* 在MongoDB中有3种数字类型(32位整数，64位整数和64位浮点数)，但是JavaScript只有一种数字类型（64位浮点数），如果在shell种进行修改的化，都会被存成该种类型，问题就会很大。shell显示的时候，会用一种近似的表现方式
* `ObjectId`，它设计成轻量型的，不同的机器都能用全局唯一的同种做法方便地生成它。
    * 它使用12字节地存储空间，每两个字节两位十六进制数字，是一个24位长地字符串
    * 还比较推荐在客户端生成该值
    {% raw %}  
    <table border="1" cellspacing="0" bordercolor="#000000" width = "80%">
        <tr>
            <td> 0 </td> <td> 1 </td> <td> 2 </td> <td> 3 </td> <td> 4 </td>
            <td> 5 </td> <td> 6 </td> <td> 7 </td> <td> 8 </td> <td> 9 </td>
            <td> 10 </td> <td> 11 </td> <td> 12 </td>
        </tr>
        <tr>
            <th colspan="4"> 时间戳 </th> <th colspan="4"> 机器 </th>
            <th colspan="2"> PID </th> <th colspan="3"> 计数器 </th>
        </tr>
    </table>
    {% endraw %}


### 2. 创建、更新及删除文档

* 批量插入可以避免零碎请求所带来的开销。消息长度最大是16MB。
* 当执行插入的时候，驱动程序会将数据转换成`BSON`的形式，然后将其送入数据库。数据库解析`BSON`，检验是否包含`_id`键并且文档不超过4MB，然后将文档原样存入数据库中。
* 当使用`update`更新整个文档时，`_id`的值是可以被改变的，但使用修改器时，`_id`的值不能改变。
* `$set`和`$unset`可以用来更新值，添加键等，`$inc`可以用来修改数值(整数，长整数，双精度浮点数)，不存在时会创建。
* **插入，删除和更新**操作，都是瞬时完成的，他们不需要等待数据库相应。
* 在`shell`中可以使用`getLastError`来检查操作是否执行成功


**数组修改器**
* `$push$`会向已有的数组末尾加入一个元素，要是没有就会创建一个新的数组。
* `$ne`可以实现，如果一个值不在数组中，就把它加进入，例如：如果`Richie`不在作者列表里，就把它加进去`db.papers.update({"authors cited": {"$ne": "Richie"}}, {"$push:{ "authors cited": "Richie"}})`
* `$addToSet`可以在加入数组的同时，避免重复。配合`$each`可以一次添加多个元素`db.papers.update({"_id": ObjectId("xxxxxxxxxxx")}, {"$addToSet: { "authors cited": {"$each": ["Richie", "Joe"]}}})`
* `$pop`可以从数组任意一端删除元素，`{$pop: {key: 1}}`从数组末尾删除一个元素，`{$pop: {key: -1}}`从头部删除。
* `$pull`可以删掉匹配部分的所有元素。
* 如果想要修改列表中元素的值，可以通过下标来直接选择元素，例如`db.blog.update({"post": post_id}, {"$inc": {"comments.0.votes": 1}}})`会给第0条`comments`的投票数+1。
* 也可以使用`$`用来定位查询文档已经匹配的元素。但它只会更新第一个匹配的元素。
* `upsert`可以在没有文档符合更新条件，就会以这个条件和更新文档为基础创建一个新的文档。
* 更新多个文档，据说`update`的第四个参数的功能
* `findAndModify`，对需要取值和赋值风格的原子性操作来说比较好，可以避免线程的竞态条件

### 3. 查询
* 查询的时候，不能引用文档中其他键的值，只能是常量。
* 查询条件包括：`$lt`, `$lte`, `$gt`和`$gte`。
* OR查询，可以使用`$in`来查询一个键的多个值，可以使用`$or`不同键的多个值
* `$not`可以用在任何其他条件上。
* 一般修改器是外层文档的键，条件语句是内层文档的键。

**查询数组**
* 每一个元素都是整个键的值。
* 使用`$all`通过多个元素来匹配数组`db.food.find({fruit: {$all: ["apple", "banana"]}})`。它可以进行模糊的匹配，不用`$all`就是精确匹配
* 使用`$size`可以用来查询指定长度的数组。查询范围建议加字段维护大小。
* 使用`$slice`可以返回数组的一个子集合，但是该文档中其他键值也会被返回。
* 内嵌文档查询，对于单个子文档键，直接用`.`即可。
* 如果要对内嵌文档的多个键进行查询，要指定一组条件，需要使用`$elemMatch`来匹配，如`db.blog.find({"comments": {"$elemMatch" {"author": "joe", "score": {"$gte": 5}}}})`
* `$where`可以执行任意js作为查询的一部分。但巨慢，不推荐
* `limit`，`skip`和`sort`。
* 处理大量文档时，可能会由于空间不足，更新的文档被移动到末尾，导致游标遍历会出现问题，返回已经处理过的文档。对于这个问题可以对查询进行快照，也就是使用`$snapshot`选项。
* 服务端游标，会消耗内存和其他资源，游标遍历结束，客户端要求终止，客户端游标不在作用域，超时等情况下，服务端的数据库游标会自动销毁，可以使用`immportal`的机制，来不让数据库超时。

### 4. 索引
* 用于加速查询
* 索引可以用`1`和`-1`表示方向，单个键的索引方向无关紧要，若是有多个键，就需要考虑方向问题了。
* 创建索引后，每次插入，更新和删除时都会产生额外的开销。
* 建立索引时，要考虑如下问题：
    * 会做什么样的查询？其中哪些键需要索引？
    * 每个键的索引方向是什么样的？
    * 如何应对扩展？有没有中不同的键的排列可以使常用数据更多地保留在内存中?
* 也可以对内嵌文档中的键家索引。
* 索引都有一个字符串类型的名字，来标识唯一索引，类似`keyname1_dir1_keyname2_dir2...`，但是有字符个数限制，特别复杂的索引应当使用自定义的名字。
* `explain`会返回查询使用的索引情况，耗时及扫描文档数的统计信息，例如`db.foo.find().explain()`
* 使用`hint`可以强制使用某个索引，但说是一般没什么必要，MongoDB的查询优化器很智能。

**索引管理**
* 索引的元信息存储在每个数据库的`system.indexes`集合中，不能对其插入删除，只能通过`ensureIndex`和`dropIndexes`进行操作。
* 同时`system.namespaces`集合也含有索引的名字。
* 使用`{"background": true}`可以使建立索引在后台完成。
* 地理空间索引，可以创建参数为`2d`的索引，如`db.map.ensureIndex({"gps": "2d"})`，挺高级的，但感觉应该用不到。


### 5. 聚合
* `count`用于返回集合中的文档数量，传递查询可以计算查询结果的数量。
* `distinct`也就是投影，必须指定集合和键。
* `group`用起来感觉挺麻烦的，要用再查吧。主要解决和分组相关的需求。
* `finalizer`完成器，用以精简从数据库传到用户的数据。
* `$keyf`可以用于定义分组函数来确定文档分组所依据的键。
* `MapReduce`是一个可以轻松并行化到多个服务器的聚合方法。比较慢，要作为后台任务来运行，结果保存到集合中。
* 花了很多篇幅介绍`MapReduce`，感觉目前不是很有必要深入学习。


### 6. 进阶指南

**数据库命令**
* 删除数据库的函数调用`db.test.drop()`，实际上是运行了`drop`命令，等价于`db.runCommand({"drop": "test"})`。
* MongoDB中的命令其实是作为一种特殊类型的查询来实现的，这些查询针对`$cmd`集合来执行。`runCommand`是接受命令文档执行等价查询，删除集合操作又等价于`db.$cmd.findone({"drop": "test"})`
* 这些命令时用一套特殊的逻辑来处理，有些命令需要管理员权限，必须在`admin`数据库里面运行。
* 在shell中运行`db.listCommands()`可以获得所有命令的最新列表。
* 常用命令：
    * `bulildInfo`查看MongoDB服务器的版本号和主机的操作系统。
    * `collStats`返回指定集合的统计信息，包括数据大小，已分配的存储空间和索引的大小。
    * `getLastError`查看对本级和执行的最后一次操作的错误信息或者其他状态信息。
    * `isMaster`检查本服务器是主服务器还是从服务器。
    * `serverStatus`返回这台服务器的管理统计信息。

**固定集合**
* 大小固定的集合，类似于一个环形队列，默认情况下没有索引。
* 不能删除文档，更新不得导致文档移动。
* 特性：1. 插入速度极快（就是一个简单的`memcpy`）。2. 按照插入顺序输出的查询速度极快。3. 能够在性数据插入时，自动淘汰最早的数据。
* 比较适合存储日志，缓存少量文档的场景。
* **创建**`db.createCollection("my_collection", {capped: true, size: 100000})`，这个命令会创建一个大小为100000字节的固定集合，
* 可以将已有的文档通过命令`convertToCapped`命令来转换成固定集合。
* **自然排序**，按照文档在磁盘上的顺序，对于固定集合而言，在磁盘上的顺序是和插入顺序一致的。例如按反向插入的顺序查询`db.my_collection.find().sort({"$natural": -1})`

**GridFS**
* 介绍了一下`GridFS`。（TODO: 虽然应该不用，但可以看下其实现源码）
* 原理：将一大文件分成很多块，每块单独作为一个文档存储。另外还有一个单独的文档用来存储分快的信息和文件的元数据。

**服务端脚本**
* `db.eval`可以在服务端执行任意的`JavaScript`脚本。例如`db.eval("print('Hello, world');");`。
* `system.js`可以用来**存储JavaScript**，可以在任何的`JavaScript`上下文中调用。
* 执行JS代码时，需要谨慎考虑MongoDB的安全性。需要使用<font color=red>限定作用域</font>

**数据库引用**
* `DBRef`唯一确定到一个文档的引用。如下所示，`$ref`表示集合，`$id`表示对应文档的键值，`$db`可选，表示其他数据库，这三者的顺序不能改变。
    ```shell
    {
        "$ref": collection,
        "$id": id_value,
        "$db": database,
    }
    ```
* 部分驱动陈故乡可以将其自动和普通文档相互转换。
* 直接存储对应文档的`_id`键也是可以的，不是非`DBRef`不可，如果需要存储一些对不同过集合的文档的引用时，就比较适合。


### 7. 管理

**启动和停止MongoDB**
* **启动**：MongoDB使用`mongod`启动，可以用命令或配置文件添加参数启动。
* **停止**：在服务端可以直接使用`Ctrl-C`停止，可以使用`kill -2 pid`或者`kill pid`来停止，会等到当前的一些任务结束后，才停止，<font color=red>不要使用`kill -9`来停止</font>，可能会导致文件损坏，若损坏就需要进行修复。

**监控**
* `mongod`会在大1000的端口启动一个http服务器，可以查看部分信息，例如MongoDB启动在了27017端口上，那么管理端口就在28017上。
* `serverStatus`可以查看MongoDB服务器的统计信息。使用`mongostat`可以输出其中的一些重要信息，并且每秒钟输出新的一行。

**认证**

**备份和恢复**
* 数据文件备份`mongodump`和`mongorestore`，能够在运行时备份
* `fsync`可以为数据库加写入锁，能在MongoDB运行时复制数据目录并且不会损坏数据，对于有快照功能的文件系统非常好用
* 从属备份
* 修复


### 8. 复制

* 主从复制: 所有从节点都从主节点复制内容，从节点并不保存自己的oplog。
* 副本集: 是有自动故障恢复功能的主从集群，整个集群会选举出一个“主节点”，当其不能工作时则变更到其他节点。
* 从节点很适合用来做读扩展和数据处理。
* `oplog`包含的键有: `ts`操作的时间戳，`op`操作类型，`ns`执行操作的命名空间，`o`进一步制定要执行的操作的文档。
* `oplog`只记录改变数据库状态的操作。它是作为从节点与主节点保持数据同步的机制。
* 日志是使用`固定集合`实现的，如果从节点跟不上同步时（已经过了一圈），复制就会停下，从节点需要重新做完整的同步`{"resync": 1}`。
* `local`时MongoDB服务器上的本地数据库，用来存放内部复制状态，主节点和从节点都有，其内容不会被复制。
* 可以使用`geLastErrorl`的`w`参数来确保数据的同步性。


### 9. 分片

* MongoDB支持自动分片，要在分片之前运行一个路由进程，名为`mongos`。路由器知道数据和片的对应关系，从中进行转发。
* 设置分片时，需要选择一个键来作为数据拆分的一句，成为`shard key`片键。
* 分片建立，配置，管理，分片命令。等等


### 10. 深入MongoDB内部

* BSON(Binary JSON)是MongoDB里文档的表达方式。
* Mongo传输协议，是在TCP/IP上简单封装。是一个简单封装的BSON数据。
* 数据文件默认在`/data/db/`中，每个数据库包含一个`.ns`文件和若干数据文件，它还会预分配数据文件，皮面文件分配所产生的阻塞。
* 在数据文件内部，每个数据库都是按照命名空间组织的，一种类别的数据与其他类别的分开存放。每个集合的文档都有自己的命名空间。其元数据存储在了数据库中的`.ns`文件中。
