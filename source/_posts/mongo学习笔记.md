---
title: mongo学习笔记
date: 2021-08-07 12:08:27
tags: [服务端开发, 数据库]
---

参考书籍：  
[MongoDB实战](/doc/MongoDB实战.pdf) 这本书是一本快速上手的手册，简单，直接，内容全面。  
[MongoDB权威指南](https://gitee.com/kadys/developer-books-01/raw/master/MongoDB/MongoDB%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97.pdf)  
[深入学习MongoDB](https://gitee.com/kadys/developer-books-01/raw/master/MongoDB/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0MongoDB.pdf) 包含两部分：MongoDB扩展技术和MongoDB开发技巧50例，前者主要是介绍如何部署分布式的数据库，后者介绍了开发中种种需要注意的地方

每本书的只有一百页左右，太棒惹。

![封面](/images/cover/mongodb.png)


<!--more -->

# MongoDB开发技巧50例

### 1. 一致性和速度折中

* 针对的问题是，多个文档关联时，是使用冗余（反范式化）的方式还是使用引用（范式化）的方式存储。
* 例如，有订单里有商品的信息，商品有单独的集合，那么订单中应该存储商品的id，还是商品的数据？
    ```json
    // 商品
    {
        "_id": productId,
        "name": name,
        "price": price,
        "desc": description
    }
    // 订单
    {
        "_id": orderId,
        "user": userInfo,
        "items": [
            productId1,     // 是存储商品id还是完整的数据条目
            productId2,
            productId3,
        ],
    }
    ```
* 如果采用范式化，每次读订单信息的时候，都需要额外再读取商品信息。
* 如果采用反范式化，那么可能会有不一致的情况。
* 实践中，商品的信息改变频率很低，且不必更新到所有订单，因此最佳选择是将订单反范式化（就存完整的商品信息）

* **范式化可使数据可用性更长久**

### 2. 尽量单个查询获取数据

* 尽量将需要一块获取的数据存到一起，这样可以一次查询。
* 如果要获取多条数据，也尽量就返回多条数据，避免多次查询。
* 如果某些信息只在一个文档中使用，就应该嵌入这个文档
* 只有一个键或一个值的也应嵌入

### 3. 不要嵌入不断增加的数据

* 对数据追加数据很低效，正常使用中数据和对象大小应当相对固定
* 会不断增加的数据，作为单独的文档处理比较合适

### 4. 预先分配空间
* 如果知道未来要用到那些字段和数据，可以预先填充数据，更新值比插入值快的多
* 如果确定未来文档的大小，可以先用辣鸡数据填充，再重置字段，可以预分配足够的空间

### 5. 数组和子文档存储权衡
(TODO: 补充例子)
* 如果想无需标识符就获取某项的信息，就要用数组存储
* 如果明确知道查讯的属性，就可以采用文档存储

### 6. MongoDB应只存取数据
(TODO: 补充例子)
* 尽量通过优化文档结构，使得信息可以直接从文档中获得，避免让MongoDB使用JavaScript计算
* 如果在更新文档时，不确定某些字段是否需要更改，可以用两种修改：
    1. 硬改，让后台任务或客户端校验修复不一致的情况
    2. 使用`findAndModify`锁住文档直至修改完毕

### 7. `$where`理解
* 可以在查询中使用`$where`自子句来执行JavaScript代码。灵活但低效
    ```js
    > db.members.find({"$where": function() {
        return this.member[0].age == this.member[1].age;
    }})
    ```
* 使用普通查询会转换成`BSON`格式与MongoDB中进行数据对比。使用`$where`会将文档转为js对象并执行对应脚本
* 使用`$where`时可以通过条件减少要匹配的文档，以减少性能消耗。

### 8. 数据问题
* 系统奔溃，MongoDB更新可能会导致数据不一致
* 可以通过建立`cron`任务进行修复
    * 一致性修复器：核对计算，检查重复数据，确保数据一致性
    * 预分配器：创建今后要用到的文档
    * 聚合器：更新文档内部的聚合数据，使之为最新数据
    * 结构校验器：确保当前所有的文档都有指定的字段，否则就自动校正或发送通知。
    * 备份任务：定期对数据库做`fsync`，加锁和到处操作

### 9. 用正确的类型存放数据
* 数字：`AND`和`OR`操作只适用于整数，不能是双精度浮点数。数据库会自动转化溢出的32位浮点数，将其变成64位的。
* 日期：是**精确**的日期就要存成日期的类型，不精确的可以存成`yyyy-mm-dd`形式的字符串ISO格式的日期。
* 字符串：都是utf-8编码的，或者以二进制形式存储
* `ObjectId`：<font color=red> 就以`ObjectId`存储，不要存成字符串 </font>。
    * 字符串无法与`ObejctId`相匹配，方便查询
    * `ObjectId`中包含文档的创建日期等，（听一个分享说是：[创建时间 : 主机号 : 进程号 : 序号]）
    * 字符串要比`ObjectId`多占用两倍空间
* 如果数据本身具有唯一的字段，可用来做_id，但是要**确保其唯一性**，要留意**索引的树结构，保证插入顺序是有序的**
* 不要用文档作为`_id`，以下是书中的说明，（然而并没有很懂：
    > 除了不可避免地情况（如MapReduce）地输出，通常都不应该将文档作为`_id`。问题就在于索引一个文档中的字段和索引文档完全不一样，如果没有每次查询整个子文档的计划，最后会有多个索引，如`_id`，`_id.foo`，`_id.bar`等。
    更改`_id`必须得覆盖整个文档，所以若子文档的字段有变化则更新非常不便。

### 10. 不要用数据库引用
* 数据库引用如下，它表示该文档引用了`dbName`数据库中`dcollectionName`集合的`identifier`文档。
    ```js
    {$id: identifier, $ref: collectionName, $db: dbName}
    ```
* 它仅仅是一个普普通通的子文档，并没有什么神奇之处，依旧要进行一次额外的查询。
* 例如系统中的用户可以系统中的任意一件事情，可以通过数据库引用来存储对应的集合。

### 11. 不要使用`GridFS`处理小的二进制数据
* 查询`GridFS`需要查询两次，一次获取文件的元信息，另一次获取其内容。
* 它是用来将大的二进制对象切成小片存放到数据库中的。

### 12. 处理故障
* MongoDB在进行无缝的故障切换时，可能会抛出网络错误和异常，需要用户自行处理
* 主节点异常时，可能会出现各种错误，此时也需要多多注意各种问题的处理

### 13. 优化
* 尽量减少磁盘访问
* 使用索引减少内存占用
* 如果要大约返回集合的一半数据的时候，就不要使用索引了。
* 每次插入删除文档时，需要同步更新索引，因此索引会增加很多额外的写入。

### 14. 索引使用
* 如果索引覆盖了整个查询的字段，那么这种查询会直接用索引的数据返回结果，不再访问文档;  
    例如当前有如下索引：`db.foo.ensureIndex({"x": 1, "y": 1, "z": 1})`，在进行查询`db.foo.find({"x": criteria, "y": criteria}, {"x: 1, "y": 1, "z": 1, "_id": 0})`查询时，会之访问索引的数据，不访问整个集合的数据
* 尽量建立能被多个查询利用的复合索引。只要索引开头部分匹配就能利用索引。

### 15: 文档和查询的设计
* 如果属性平铺在了整个文档中时，查询时会不得不遍历每个字段，内嵌文档可以减少字段的访问。
* `AND`类型的查询，尽量先将过滤条件严格的放在前面，这样后面的查询搜索空间就小了很多。
* `OR`类型的查询，和上面的相反，应将匹配结果较多的放在界面，这样后续的查询搜索空间会少很多

### 16. 数据安全性和一致性
* 单机做日志，多机则复制，或者两者兼用
* 数据库崩溃了，并且没有日志，运行`repair`的修复时有限甚至无法修复的，比较推荐的做法时从备份快速回复，或者从头开始同步。**但一定要清除所有损坏的数据**
* 对于某些重要的操作，可以通过设置`w`发送`getlasterror`到服务器等待`w-1`个节点完成才当作写入成功；如`db.runCommand({"getlasterror": 1, "w": num， "wtimeout": 100})`来保证数据的安全性。同时一定要给`w`设置超时。
* `fsync`选项可以保证日志中有记录，但会让应用程序暂停直至写入磁盘，会特别影响性能，而且绝不要在未开启日志时使用`fsync`。
* 在有日志的情况下，数据库奔溃后重启时，会自动修复数据才开始接受连接，但比repair节省很多时间，日志千万不要删除。
* 备份文件时，使用`fsync`和锁配合，然后到处数据，不能没有执行`fsync`和上锁就直接复制所有文件，可能会损坏数据文件。

### 17. 管理技巧
* 手动清理块集合，也就是`GridFs`文件。
* 不要改变复制组成员投票的权值。
* 无活跃节点时可重置复制组
* 不必指定`--shardsvr`和`--configsvr`参数
    * `--configsvr`会默认更改端口为`27019`和开启`diaglog`
    * `--shardsvr`会将端口默认修改为`27019`
* 开发时使用`--notablescan`会在查询做全表扫描时返回错误，只能使用索引进行查询
* 在shell中管理所有服务器和数据库，它可以连各个服务器，一个shell管理所有的。
* 创建启动文件，也就是写个js文件，启动时执行好了
* 自定义全局函数  
    例如添加一个`getOplogLength`的函数到数据库类中，那么可以在初始化之前执行：
    ```js
    DB.prototype.getOplogLength = function() {
        var local = this.getSisterDB("local");
        var first = local.oplog.rs.find().sort({$natural: 1}).limit(1).next();
        var last = local.oplog.rs.find().sort({$natural: -1}).limit(1).next();
        print("total time: " + (last.ts.t - first.ts.t) + " secs");
    };
    ```
    对于已经在使用的数据库，就需要逐个添加属性到实例对象里
* 使用单个连接读取自身写入，这样可以保证写入和读取的顺序一直。

### 18. 学习JavaScript
* 推荐了《JavaScript语言精粹》


*** 

# MongoDB权威指南

### 1. 数据类型

* MongoDB支持如下的数据类型：
    null, 布尔，32位整数，64位整数，64位浮点数，字符串，符号，对象id，日期，正则表达式，js代码，二进制数据，最大值，最小值，未定义，数组，内嵌文档。
* 在MongoDB中有3种数字类型(32位整数，64位整数和64位浮点数)，但是JavaScript只有一种数字类型（64位浮点数），如果在shell种进行修改的化，都会被存成该种类型，问题就会很大。shell显示的时候，会用一种近似的表现方式
* `ObjectId`，它设计成轻量型的，不同的机器都能用全局唯一的同种做法方便地生成它。
    * 它使用12字节地存储空间，每两个字节两位十六进制数字，是一个24位长地字符串
    * 还比较推荐在客户端生成该值
    {% raw %}  
    <table border="1" cellspacing="0" bordercolor="#000000" width = "80%">
        <tr>
            <td> 0 </td> <td> 1 </td> <td> 2 </td> <td> 3 </td> <td> 4 </td>
            <td> 5 </td> <td> 6 </td> <td> 7 </td> <td> 8 </td> <td> 9 </td>
            <td> 10 </td> <td> 11 </td> <td> 12 </td>
        </tr>
        <tr>
            <th colspan="4"> 时间戳 </th> <th colspan="4"> 机器 </th>
            <th colspan="2"> PID </th> <th colspan="3"> 计数器 </th>
        </tr>
    </table>
    {% endraw %}


### 2. 创建、更新及删除文档

* 批量插入可以避免零碎请求所带来的开销。消息长度最大是16MB。
* 当执行插入的时候，驱动程序会将数据转换成`BSON`的形式，然后将其送入数据库。数据库解析`BSON`，检验是否包含`_id`键并且文档不超过4MB，然后将文档原样存入数据库中。
* 当使用`update`更新整个文档时，`_id`的值是可以被改变的，但使用修改器时，`_id`的值不能改变。
* `$set`和`$unset`可以用来更新值，添加键等，`$inc`可以用来修改数值(整数，长整数，双精度浮点数)，不存在时会创建。
* **插入，删除和更新**操作，都是瞬时完成的，他们不需要等待数据库相应。
* 在`shell`中可以使用`getLastError`来检查操作是否执行成功


**数组修改器**
* `$push$`会向已有的数组末尾加入一个元素，要是没有就会创建一个新的数组。
* `$ne`可以实现，如果一个值不在数组中，就把它加进入，例如：如果`Richie`不在作者列表里，就把它加进去`db.papers.update({"authors cited": {"$ne": "Richie"}}, {"$push:{ "authors cited": "Richie"}})`
* `$addToSet`可以在加入数组的同时，避免重复。配合`$each`可以一次添加多个元素`db.papers.update({"_id": ObjectId("xxxxxxxxxxx")}, {"$addToSet: { "authors cited": {"$each": ["Richie", "Joe"]}}})`
* `$pop`可以从数组任意一端删除元素，`{$pop: {key: 1}}`从数组末尾删除一个元素，`{$pop: {key: -1}}`从头部删除。
* `$pull`可以删掉匹配部分的所有元素。
* 如果想要修改列表中元素的值，可以通过下标来直接选择元素，例如`db.blog.update({"post": post_id}, {"$inc": {"comments.0.votes": 1}}})`会给第0条`comments`的投票数+1。
* 也可以使用`$`用来定位查询文档已经匹配的元素。但它只会更新第一个匹配的元素。
* `upsert`可以在没有文档符合更新条件，就会以这个条件和更新文档为基础创建一个新的文档。
* 更新多个文档，据说`update`的第四个参数的功能
* `findAndModify`，对需要取值和赋值风格的原子性操作来说比较好，可以避免线程的竞态条件

### 3. 查询
* 查询的时候，不能引用文档中其他键的值，只能是常量。
* 查询条件包括：`$lt`, `$lte`, `$gt`和`$gte`。
* OR查询，可以使用`$in`来查询一个键的多个值，可以使用`$or`不同键的多个值
* `$not`可以用在任何其他条件上。
* 一般修改器是外层文档的键，条件语句是内层文档的键。

**查询数组**
* 每一个元素都是整个键的值。
* 使用`$all`通过多个元素来匹配数组`db.food.find({fruit: {$all: ["apple", "banana"]}})`。它可以进行模糊的匹配，不用`$all`就是精确匹配
* 使用`$size`可以用来查询指定长度的数组。查询范围建议加字段维护大小。
* 使用`$slice`可以返回数组的一个子集合，但是该文档中其他键值也会被返回。
* 内嵌文档查询，对于单个子文档键，直接用`.`即可。
* 如果要对内嵌文档的多个键进行查询，要指定一组条件，需要使用`$elemMatch`来匹配，如`db.blog.find({"comments": {"$elemMatch" {"author": "joe", "score": {"$gte": 5}}}})`
* `$where`可以执行任意js作为查询的一部分。但巨慢，不推荐
* `limit`，`skip`和`sort`。