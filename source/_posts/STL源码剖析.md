---
title: 《STL源码剖析》笔记
date: 2019-08-13 23:49:33
tags: 笔记
---

求一个好offer！ 继续加油！！

![good_offer](https://github.com/wz2671/wz2671.github.io/blob/master/static/images/blog/good_offer.jpeg)


<!--more -->


# 泛型编程和模板
1. 据说这是本书的基础知识，在这儿就非常简单地温习和说明一下。
2. 在C++中特别的一个部分是函数重载技术，它可以让函数根据不同的参数或返回类型执行不同函数体，很多情况下只有参数的类型不同，此时会导致大量的重复劳动，因此出现了泛型编程思想，其实现一般由函数模板和类模板来实现。我们可以利用`template <typename T>`来声明使用模板。在调用函数时，编译器就会自动地生成新的函数，转化成对应的类型。
3. 编译器无法推导出返回值类型，因此必须指定返回值模板类型。同时函数模板不接受隐式转换。（优先普通函数，再隐式转换，最后再匹配模板）
4. 类模板常应用于数据结构方面，使得类的实现更关注于功能，不关注于数据类型，声名等方式与函数类似。类模板可以通过**特化的方式**实现特殊情况，所谓特化的方式，分为部分特化和完全特化，部分特化 要指定模板类型和参数（类似于类重载思想），完全特化的类模板，就是参数都是`void*`类型。特化也称偏特化（Partial_specialization）。
5. 在看书时遇到的一个疑惑，拷贝构造函数和赋值构造函数的区别，拷贝构造函数调用情况`A a = b`和`A a(b)`；而赋值构造函数调用情况`a=b`。关键是看对象有没有已经被创建。

# STL概论
1. 六大组件 ：容器，迭代器，算法，配置器（allocator），仿函数（functors），配接器（adapters）
2. 组态：**参数推导**（就是不必显式声名参数类型，根据调用时传递的形参，自动调用对应的模板类）；**偏特化**（类似于重载，就是定义多个类模板，在类前面声名模板，在类名后面也要声名，还有种叫全特化，只需要声名`template<>`）
3. 在使用仿函数时经常使用**临时对象**进行调用对应的重载函数‘()’。之前采用的一般是函数指针，但是函数指针无法拥有自己的状态？？，但放函数可以。
4. 迭代器的设计为前闭后开的区间，last元素表示的是最后一个元素的下一个位置。

# 空间配置器
1. 指的就是allocator，用来为STL容器中的元素分配内存，包含的操作有：allocate; deallocate; construct; destroy。分别对应着分配内存，释放内存，调用构造函数，析构函数。
2. 构造函数`construct()`是一般情况下是调用`placement new`运算符，接受一个指针和一个初始值，在指针指向的空间内构造对应的对象并用初始值进行初始化。
3. 析构函数`destroy()`有两种实现，对于单个指针的参数，直接调用析构函数，对于是两个指针范围，会判断一下数据的类型，如果对象的析构函数是无关痛痒的实现，就什么也不做就结束，否则，就挨个调用对应的析构函数。（其中判断对象是否是无关紧要的，通过`__type_traits`实现）
4. 内存分配`allocate()`采用了双层级配置器（还有一层包装`simple_alloc`），第一层直接使用`malloc()`和`free()`，第二层采用了不同的策略来分配内存，两种情况，申请内存大于128k和小于128k，大于128就直接用一层的内存分配器，**小于128k时**，为了降低额外的分配负担和内存碎片等问题，使用内存池技术。所谓内存池，是16个自由链表，每8个字节对应一个链表，实际分配时按8的倍数向上取整，（那个区块还采用了联合体来节约指针的内存），在16个free_list中寻找最合适的那个。
5. `free_list`中内存不足时，就从heap中进行分配，为内存池注入活水。还有个函数，用于初始化`uninitialized_fill_n()`函数，会根据对象是不是**POD**基本数据类型，来用二进制拷贝或者调用构造函数进行初始化。

# 迭代器
1. 在STL库中，算法`algorithm`和`containers`是彼此互相独立的，但是，`iterator`充当了算法和容器的胶合剂。
2. 迭代器的底层实现是智能指针，也就是对原始指针进行封装，智能指针的话主要是解决内存泄漏问题（一般采用列表初始化去初始化智能指针对象）。对于迭代器而言，最重要的操作就是`dereference`和`member access`，也就是`->`；`*`和`.`操作。
3. 也要对迭代器对象实现`operator++`等操作，为了不暴露对应的型别，利用参数推导机制，把这些操作的工作用一个模版类实现，在这个模板类中调用对应的类的实现。也就是`Traits`编程技法，主要解决的一个问题是推测返回类型，这个问题的解决方法是通过在结构体对返回值的类型做**内嵌型别声名**，也就是用`typedef T value_type`对返回值的类型进行声名，除此之外，还采用偏特化技术来处理调用该模板的元素是不能用型别声名来处理的情况（一般指的是普通的指针）。通过种种操作，`traits`就可以萃取出真实的`value type`，自动确定返回的数据类型。因此这玩意也被称为“特性萃取机”。
4. 总结一下上述，每个迭代器都应该定义自己的`associated type`，`traits`可以利用**偏特化**和**参数推导**机制自动确定迭代器的类型和返回类型。
5. 迭代的相应型别（我觉得就是各种运算符重载的实现而已）包括：`value type`，`difference type`，`reference type`，`pointer type`，`iterator_category`。

# 序列式容器
1. 序列式容器包括`vector`，`list`，`deque`，`stack`，`queue`，`priority-queue`。其中`stack`和`queue`的实现是对`deque`的封装，因此它也被称为配接器`adapter`。

### vector
1. 向量，和数组`array`非常相似，向量的空间运用更加灵活。`vector`是动态空间，会随着元素的加入，内部机制会自行扩充空间以容纳新元素。
2. `vector`的迭代器也支持随机存取。所以要重载`operator[]`操作，好多迭代器返回的都是引用。`capacity()`函数返回容量（已经存储的个数）。
3. 扩容的过程是，“重新配置、元素移动、释放原空间”等过程。扩充的容量为`old_size + max(old_size, n)`。
4. 在尾部操作的效率较高`push_back()`，`pop_back()`。但是在头节点附近插入删除的效率极低。
### list
1. 底层实现是双向链表，对空间的运用极为精准，没有一丝浪费，对于任何位置的元素插入和删除，`list`永远是常数时间。
2. `list`的迭代器也要支持正常的递增，递减，取值，成员存取等操作。并且插入等操作也不会使迭代器失效。为了实现迭代器前闭后开的要求，list节点中还在尾端放置来一个空白节点。**插入元素**一般是在插入位置之前。
3. 元素的操作包括：`push_front, push_back, erase, pop_front, pop_back, clear, remove, unique, splice, merge, reverse, sort`。
4. `unique`只能去除相邻相同元素。它的内部有一个`transfer`操作，也就是将`[first, last)`内的所有元素迁移到`position`之前。对外开放的是`splice`操作。

### deque
1. `deque`是一种双向开口的连续分段线性空间。可以在头尾两端分别做元素的插入和删除操作。它具有动态分段的连续空间，没必要提前预留一大段空间。它的迭代器复杂度较高，效率较低。对`deque`进行排序也是很低效的，可以先完整的复制到`vector`中，在进行排序复制回来。
2. 在复杂的迭代器架构代价下，`deque`实现了在其前端或尾端增加空间，避免了`vector`的“重新配置、复制、释放”。整体连续只是假象。
3. 具体实现：它有一个二重指针`map`用来指向类型为`T*`的一个指针数组。每个元素是一个`T*`类型的指针，默认采用*512字节*缓冲区。
4. 迭代器具有四个指针，分别为`cur`，`first`，`last`，`node`。`cur`指向缓冲区中的当前元素位置，`first`指向缓冲区的头节点，`last`指向缓冲区的尾节点，`node`节点指向`map`中元素的对应位置。
5. 实现迭代器运算符重载时，要注意对于边缘区域，要视前进后退情况而定，要解决不在同一缓存区的问题。
6. 除此之外，`deque`还要维护两个`start`和`finish`指针，分别指向第一个缓冲区第一个元素和最后一个缓冲区的最后一个元素。
7. 当内存不够时，要扩充内存，这个过程稍微复杂，如果缓冲区只剩一个备用元素是，再调用`push_back()`会调用`push_back_aux()`，然后再分配一块缓冲区。
8. 删除元素时，也有`pop_back_aux()`操作，就是删除最后一个缓冲区，只有当这个缓冲区不用了。但至少也会有一个缓冲区。

### stack
1. `stack`缺省以`deque`作为底部结构并封闭其头端开口，实现非常简单。这类容器也被称为配接器`adapter`。
2. 它没有迭代器，不能被遍历，只能访问顶端的元素。
3. 也可以以其他元素为底层容器，例如: `list`。

### queue
1. 也是以`deque`作为底部结构，封闭其底端的出口和前端的入口。
2. 也没有迭代器，不能便利。

### heap
1. 鼎鼎有名的堆（本科时从来没想去搞明白，现在被逼着随手就是个堆排序😑），本质上就是个完全二叉树，大顶堆的要求是父亲节点比子节点都大，小顶堆反之。在STL中，堆用来做优先队列`priority queue`的底层机制。它的复杂度最好间于`queue`和`binary search tree`之间。
2. 完全二叉树可以用一个array表示，把0号元素留空，那么第i个元素的左子树和右子树分别是2i和2i+1。`heap`还需要动态扩展，其一般用`vector`实现，新加入的元素就在`vector`的`end()`处。
3. 其核心操作就是**调整**过程，除此之外还有`push_heap`，`pop_heap`，`sort_heap`，`make_heap`操作。

### 优先队列
1. 优先队列就是有权重观念的队列，权重高的优先出来，缺省情况下优先队列利用一个`max_heap`完成。它的底层是`heap`，因此也属于`adapter`。
2. 它也没有迭代器，不提供遍历功能。

### slist
1. 它是前向的单向链表，所耗用的空间更小，操作更快。它的插入等操作不会使原迭代器失效。
2. 它要访问任何元素，都必须从头访问，因此只有在头节点处的操作才比较高效。也正因此，它只提供`push_front()`操作。
3. 它的迭代器的结构是这样的：首先有一个节点的结构体基类`struct __slist_node_base`，它的迭代器基类`struct __slist_iterator_base`有一个节点元素（节点基类指针），然后迭代器和节点分别继承自节点基结构体和迭代器基结构体。
4. 需要注意的是，它迭代器的尾端是`0`，因为它的源码是`iterator end() {return iterator(0);}`。

# 关联式容器
1. 分为两大类：`set`和`map`映射表。他们的底层是以红黑树实现的（`multiset`，`multimap`）。除此之外，还有散列表`hash table`，以它为底层机制完成的`hash_set`、`hash_map`、`hash_multiset`、`hash_multimap`。
2. 关联式容器的意思就是每个元素都有一个键值`key`和一个实值`value`，当元素被插入到关联式容器中时，容器的内部结构会依照其键值将元素值放置到合适的位置。
3. 为了获得良好的搜索效率，其内部结构一般用查找树实现，其种类有`AVL-tree`，`RB-tree`，`AA-tree`，应用最广泛的是红黑树。
4. 在二叉搜索树中寻找值比较简单，比较麻烦的是元素的插入和删除。**删除节点**：若无右子树则用左子树节点，若有则用右子树最左节点代替。
5. 平衡二叉树就是没有哪一端节点的深度过大，这样可以保证查找的效率比较高，利用平衡二叉树，元素的搜索时间平均而言，可以节省25%。

### 平衡二叉树
1. 要求任何节点的左右子树高度相差最多1。
2. 根据插入的情况可以将情况分为4种，
    * 左子节点的左子树（一次单旋转，将父节点调到爷爷辈）
    * 左子节点的右子树（两次单旋转，将左子节点调到爷爷辈）
    * 右子节点的左子树
    * 右子节点的右子树
3. 说来抽象又复杂，如果回忆不起来记得取补补书本啊（p204-207）

### 红黑树
1. 四个特性：
    * 每个节点不是黑色就是红色
    * 父亲节点为黑
    * 红节点不可以连续出现
    * 任意一条路径上经过的黑节点个数相同
2. 插入节点，有些时候要旋转1-2次再加上变色，有些时候只要变色。个人简单小总结一下。其实就是在平衡二叉树的情况下再进行了细分，并不是一定要旋转，什么情况下不用旋转呢？以上述的平衡二叉树情况1为例，如果插入为左节点的左子树，那么当有右子树存在时，就只需要变色，没有右子树就要旋转。**综上**，只要判断节点的兄弟节点是否存在就可以决定是否要旋转了，旋转的方式也和平衡二叉树一致。
3. 迭代器是继承自节点的结构体，对运算符进行了重载，每个节点有一个指向父亲节点的指针，可以比较方便地找到下一个节点。具体怎么找呢？其实就是中序遍历的下一个节点，**右子树的最左节点** 或者 **左子节点的父亲节点** 或者 ** 一直向上找父亲直到自己不是右子节点**。递减的操作类似。
4. 为了简化走到根节点的情况，STL实现时还定义了一个`header`节点，其中存储了`begin()`和`end()`对应树的头和尾。

### set
1. 底层时用红黑树作为`key`，有非常好的自动排序效果，它的元素值就是键值，因此不允许修改元素的值。
2. STL还提供了和元素集合相关的操作，包括求交集`set_intersection`，并集`set_union`，差集`set_difference`，对称差集`set_symmetric_difference`。
3. `multiset`的用法和`set`完全相同，唯一的差别就是允许键值重复。

### map
1. 它的元素是`pair`，同时拥有实值(`value`)和键值(`key`)，名为`first`和`second`。
2. 可以修改实值，但不可以修改键值。
3. 除此之外，它还重载了下标操作符，也就是`operator[]`，返回实值引用。
4. 键值可以重复的`map`就是`multimap`。

### hashtable
1. 散列表，它在插入，删除，搜索等操作上具有”常数平均时间”的表现。也成为了STL中`set`和`map`的标准底层机制。它的基本思想就是把值映射成为地址。
2. 用某种映射函数将大数映射成为小数（这样的函数也被称为`hash function`），对于元素碰撞问题，可以采用的解决方法包括：线性探测`linear probing`、二次探测`quadratic probing`、开链`separate chaining`等做法。有个负载系数的概念，指元素个数除以表格的大小。
3. 解决碰撞：
    * 线性探测：元素删除时只是先做个标记，整理的时候再删。该方法最主要的问题是会产生主集团问题`primary clustering`，也就是大量的元素聚集在一起，导致效率下降。
    * 二次探测：主要是用来解决主集团问题，它在产生冲突时，会一次加上1，4，9...；假设表格的大小为质数，并且保持负载系数在0.5下，平均访问次数不超过两次。而且这个操作可以转换成更高效的做法，在新扩展表格时，要为每个元素重新计算它在新表格中的位置。 它的主要问题是会造成`secondary clustering`的问题，可以用`double hashing`的方法。
    * 开链，也就是为表格元素维护一个`list`，当有冲突时，就在`list`上完成插入、搜索、删除等操作。
4. 开链的实现：`hash table`表格内的元素为桶`bucket`，每个桶维护一个`linked list`，在这儿的实现时自行维护了`hash table node`节点。桶的聚合体采用`vector`进行实现，可以动态扩充。
5. 迭代器：前进的操作是先在`list`里面遍历，到链表尾端时跳到下一个桶。没有后退的操作。
6. 在`stl_hash_fun.h`中定义了现成的`hash function`。
7. 桶的大小也是以素数来设计的，STL中预先存储了28个素数用来作为桶的大小依据。
8. 桶向量的大小和每个桶中最大元素个数相等。
9. 对于一些类型的变量（例如:`string`，`double`，`float`需要用户自己撰写哈希函数），还需要用进行一些转换，才可以进行取模。

### hash_set；hash_multiset
1. 转调`hash table`中的操作只不过没有自动排序的功能。

### hash_map; hash_multimap
1. 同上，不能自动排序。

# 算法
略

# 仿函数
略

# 配接器
同略