---
title: 《More Effective C++》笔记
date: 2019-08-3 00:04:59
tags: 笔记
---

这是《More Effective C++》一书的笔记，好书啊！
虽然是为找工作准备的，但不得不说，看这些书比自己摸索不要快太多，最近几天学了不少。
以后还是值得继续深入阅读的。

<!-- more -->

# Intruction

1. STL包含`bitset`s, `vector`s, `list`s, `queue`s, `stack`s, `map`s, `set`s等。更多细节详见《STL源码剖析》。
2. 在C++的继承机制中，指针和引用拥有动态类型和静态类型，静态类型指声明时候的类型，动态类型指得是由它们实际所指的对象来决定。
3. 内存泄漏：在生成对象时，会自动调用构造函数，调用构造函数本身也会分配资源，并且还有可能对象中存在其他的系统资源，例如文件描述符，windows句柄，锁，套接字等，会造成**资源泄漏**。
4. **指针和引用**
    * 引用不能为空，初始化时必须指向一个对象，指针可以为空。
    * 引用是变量的别名，操作它就和操作原变量本身一致，而指针本身是一个变量，它存储着指向对应类型的地址，可以用‘*’操作符对变量内容进行修改，也可以将指针内容指向其他地址。
    * 对局部变量返回引用是有很大隐患的，在栈上分配的内存会未定义，堆上分配的对象容易造成内存泄漏，一般只有某些运算符重载时才会返回引用。在某些运算符重载时返回引用会导致操作很奇怪。
    * 如果我们需要一个不会变化的指向某个对象的某种能力，那么我们就该使用引用，而且它的效率更高。
5. 转型操作符
    * 针对C语言的强制类型转换的不足弥补并扩充了一些功能。主要有4中转型方法`static_cast`，`dynamic_cast`，`const_cast`，`reinterpret_cast`，使用方法就是`static_cast<type>(expression)`。看起来也非常直观，容易进行分析。
    * 最常用的就是静态转型了，它首先就可以取代C语言中强制类型转换，除此之外，它也可以用在多态场景下的向下转换等。以前C语言中不能做的它也不能做。
    * 常量转换主要是针对于常量性事物和volatileness的变量进行转换，可以常量的常量性去掉，也就可以进行修改之类的了。
    * 动态转换主要用于涉及继承基址的转换，可以将父类对象强行转换成一个子类对象，也就是向下转换，转换失败会返回null或抛出异常。
    * 重解释类型转换，功能比较强大，但是可移植性很差，适具体的应用场景而定。比如可以对函数指针转型等。
6. 数组中的多态
    * 所谓多态，就是根据指针指向的对象动态决定**指向的类的内容**，我们如果把一个父类对象数组名（指针）指向一个子类对象数组，在进行索引或者对指针加上偏移值时，编译器是根据父类对象大小计算地址偏移的，但是实际却是计算的子类对象大小，访问的行为就有问题。
    * 在删除元素，释放内存也是不行的，偏移的计算有问题。
    * 多态和数组以及指针都不要混用。
7. 如果不提供默认构造函数
    * 可以采用no-heap数组。可以用指针数组。
    * 可以将内存分配和函数构造分开来调用，这儿有两种`new`操作，`operator new`和`placement new`。前一个指显示调用`new`操作符，形式是就是`void *xx = operator new[](many size);`，调用这个只会分配最原始的内存，不调用构造函数，释放内存时也要采用类似的显式调用方法。后一个操作就是对已分配的内存调用构造函数，创建对象，形式为`new (&xx) class()`，在释放内存之前也要手动调用析构函数。
    * 没有构造函数时，首先**创建数组就很麻烦**，没有那种初始值，其次许多**标准库STL**中提供的模板就不可用了。最后，继承状态下必须要给基类提供初始值。

***

# Operators

1. 类型转换函数
    * 在C++中存在着许多的隐式类型转换，除了我们熟知的将低精度向高精度的转换以外，在我们自己定义的类型中，编译器会根据我们提供的函数来作隐式转换之用。
    * 主要有**两种**转换方式：**只有一个自变量的构造函数**，例如`Array(int size)`可能会把`int` 类型转换成`Array`；**隐式类型转换操作符**`operator double() const;` 会在类型不匹配时自动调用（1.类型转换时，最好显示进行调用，2.利用关键词`explicit`声明，3.超过两层的类型转换（两次构造函数调用时不行的），定义内部类（代理类），将单变量作为内部类的参数，4.函数重载技术）。
2. `++i`和`i++`操作符的前置式和后置式。
    * 区分通过运算符重载，后置式有一个`int`自变量，虽然不用，但可以帮助对象区分调用对应的重载函数。
    * 函数体内主要的操作就是增加和返回值，后置的需要生成一个临时变量并按值返回，前置返回`*this`变量的引用。因此前置的运算更佳，不需要产生临时变量。
    * 为了防止多次后自增加(`i++++`)操作，一般要声明返回值为常量类型，一是避免产生歧义，二是本身也不对，对后一个操作是对临时变量进行自加操作，三是标准运算中也不合法，但前置的是合法的。
3. 避免重载`&&`，`||`和`,`操作符
    * 众所周知，`&&`和`||`运算符会有断路操作，也就是如果判断出前部分表达式的结果了，后半部分就不会判断了，但是经过重载之后，该表达式的表现形式是以调用重载函数来实现的，但是，编译器并不会保证表达式的两端到底谁先执行谁后执行，而直接执行后部分很有可能导致程序奔溃，因此不行。
    * 还有一些操作符是不可以重载的，例如`.` `.*` `::` `?:` `new` `delete` `sizeof` `typeid`以及各种类型转换。需要注意的是`operateor new`和`operator new[]`等是可以重载的。
4. `new`和`delete`
    * `void* operator new(size_t size)`可用来负责内存的申请
    * placement new可以用来调用构造函数。
    * 对应的数组版本应该使用`operator new[]`进行内存分配。
    * 我们只能对分配释放内存的方式进行修改。

***

# Efficiency

1. 82法则
    * 利用分析器分析时间，调用频率，内存等
    * 重现输入的数据
2. lazy evaluation
    * 缓式做法就是编译器在用拷贝构造函数或赋值函数创建新对象时，可能并不会创建，而是做个记录，并指向那块内存。只有在真正要用的时候，才真正分配内存。
    * 例如对于读写操作，读的话可以只访问第一份链接的内存，在写的时候再重新分配内存到对应的对象，然而一般情况下我们很难判断`operator []`到底是在读还是在写（到底是左值还是右值）。然而可以用代理类延迟决定。
    * 如果我们的程序使用大型对象时，每次从数据库中取一个大对象就非常耗时，并且我们实际应用时可能只用其中的一两个字段，因此，一个更好的做法就是我们并不一次性把整个对象读出来（初始化为空），而是在需要某个字段时，再读出来（`mutable`声明是指这样的字段可以在任何成员函数中被修改）。
    * 在计算某个表达式时，比如矩阵运算，我们可以等真正取数的时候再对表达式（就要取的那一项）进行计算，很多情况下大部分数值是用不到的。
    * 在操作系统中也有非常多的应用，很多进程会共享某些页（创建进程fork），只有在特定进程写某些页时才会进行复制操作（copy-on-write）。
3. 分摊计算成本
    * 最常用的就是缓存技术，当我们需要某些功能例如最小值等时，我们可以设计专门的数据结构进行优化，多次查询时也可以用高速缓存完成任务。
    * 申请内存时可以预先申请一大块内存，节约系统调用分配时间。
4. 临时对象
    * 函数调用结束时按值返回某个对象。（如果返回的是一个变量，编译器会自动进行优化，不再创建临时变量，也即是返回值优化`return value optimization`）。
    * 调用函数时，按值（或者`reference-to-const`）传入某个参数。
    * 隐式类型转换时也会生成临时对象。（在利用函数重载消除隐式类型转换，要注意每个‘重载操作符’必须至少有一个‘用户定制类型’，全是基本类型会导致原始意义改变）。
5. 使用(`op=`)取代(`op`)独身操作形式
    * 独身版本通常返回一个新对象，因此要调用构造析构函数，而复合版本可以将结果直接写入左值（左端自变量），因此效率更高。
    * 代码写的好还可以进行返回值优化，匿名对象而且更加容易被消除。
6. 针对自己程序的性能瓶颈，更针对性地调用相应地库。因为许多库的设计是针对某一具体问题，有某种特定优势。
7. 虚函数，多重继承，虚基类，运行时识别(runtime type identification)
    * 上述的东西底层实现都离不开虚表(virtual table; vtbls)和虚表指针(virtual table pointers; vptrs)，每个类继承或声明了虚函数，那么它就会拥有自己的一个虚函数表，里面的内容是各个类实现虚函数体的指针，子类中有重写的类，那么它会用它的函数指针取代父类函数指针的位置。
    * 一般虚函数表放在定义了虚函数的那个类中，但是，如果将虚函数声明为`inline`，那么这个虚函数就会在每一个使用了它的目标文件中产生虚函数表，就比较烦。
    * 每个对象拥有一个虚表指针，用来指向虚标，占内存4字节，也用来在对象调用虚函数时自动指向调用的函数。
    * 至于动态调用函数，首先根据对象的虚表指针找出虚标的位置，再找出调用函数在虚表中的位置，然后再调用对应的函数。（(`*pC1->vptr[i])(pC1);`）它从原理上来说就是和`inline`相对的，一个时动态，另一个是相对静态。
    * 虚拟继承出现在多重继承菱形图中。用了虚拟继承之后从此远离歧义，大家都有相同的父亲，在具体的实现中，就是继承的父类可能都拥有一个指针指向相同的虚基类（这就导致了额外的内存开销）。在应用场景下，是先调用虚基类的构造函数，再调用父类的构造函数，（调用成员变量的构造函数），最后再调用自身的构造函数。
    * 可使用`typeid`操作符取得某个类相应的`type_info`对象，这个对象中存储着运行时识别信息，和虚表之间有着某种平行关系，根据`class`的虚表来实现。

***

# Techniques

1. 将构造函数和非成员函数虚化
    * 为什么要将构造函数虚化呢？情况是这样的，我们可能希望我们动态地根据输入数据，产生不同类型的对象，也就是调用不同的构造函数，而此刻，就需要虚拟构造函数了。
    * 如何实现呢？很简单，就是在不同的类中（有继承关系），将构造函数封装起来，利用成员函数的动态调用特性，实现构造函数的多态性，这种操作一般被称为`virtual copy constructor `。动态地调用派生类的拷贝构造函数。（这里利用了父类构造函数的返回值不必和子类的构造函数返回值相等，但要有继承关系。）
    * 非成员函数虚化，指的是很多函数并不是类中的成员函数，例如输出流运算符(`virtual ostream& operator<<(ostream& str) const;`)，使用运算符重载时会导致应用不太正常，因此更好的做法是，声名一个虚函数，用作打印之用，这样就不必把运算符重载操作声名为虚函数，可以实现非成员函数的行为虚化。
 1. 限制某个class能产生的对象数量
    * 允许一个或零个对象，方法就是把构造函数声明为私有类型，然后可以定义一个友员函数声明该类的一个静态对象用于给访问者共享。不用友员函数也可以用静态成员函数，这样也可以防止友员函数占用全局命名空间。为了防止和其他类产生命名冲突，还可以使用**命名空间**。（在函数中定义静态变量，是一种哲学，对象只有在被用到的时候会付出代价。而且，最好不要把有静态变量的函数声名为`inline`。）
    * 还有一种方法，定义一个静态成员，用于计算产生的对象个数。（注：静态成员变量应该在类外定义赋值）
    * 但是，上述方法如果有继承关系或着有父类的成员变量，子类对象若想生成对象，必然会调用父类的构造函数，间接地修改父类中所定义的静态成员变量。（因此我们最好不要继承具体类`concret class`）。又可是，如果父类的构造函数是私有的，并不能被继承。
    * 可以用智能指针动态地创建对象并自动释放。还可以创建一个基类专门用来计数。
2. 对象和heap
    * 要求对象产生于堆，也就是说不能不用`new`来生成对象，一个比较好的方法就是，将析构函数声明成私有函数，因为`new`出来的对象是需要显式调用析构函数的，封装起来后就是换个名字，但在栈上的对象就不能自动释放了，也就会报错。（可是又会妨碍继承，所以声明为保护型更好。）
    * 判断某个是否生成在堆上：通过重载`operator new`是不行的，因为对于数组它只会调用一次。通过地址来判断也是不行的，因为静态变量的地址位通常更低但构造函数却无法判断。还有个想法是在`new`操作中加入描述符来表示分配的对象。
    * 禁止对象产生于堆：把`operator new`和`operator delete`声明为私有对象。
3. 智能指针
    * 本书中智能指针部分的内容似乎有些过时，因为据我所知（看别人面经），现在的指针都是`unique_ptr`,`share_ptr`,`weak_ptr`之类的了。这儿介绍了三个核心内容：智能指针的构造和析构，赋值和复制，解引（也就是用它）。
    * 每个智能指针的背后，都有一个智障指针，他们才是故事的主角，构造函数中会为对象调用构造函数，析构函数会释放指针所指向的内存。
    * 但是！在智能指针中有一个**对象拥有权**的概念，赋值操作会导致对象的拥有权转移，此时，就不能采用按值传递的方式传参之类的，因此对引用的传递应该用`pass-by-reference-to-const`才是合理的方式。还有，在智能指针的拷贝构造函数和赋值函数中，参数不再是常数类型的了，因为拥有权转移的存在，会对参数的内容进行修改。
    * 解引操作指的是`ptr->`和`(*ptr).`，要注意一点就是返回值时要返回对象的引用，不能按值返回，按值返回在多态的情况下，会导致对象的切割问题，传入一个派生类的对象，却返回的只有基类的部分。
4. 引用计数
    * 可以用引用计数构建出垃圾回收机制。
    * 可以节约内存分配，只要判断引用计数是否为0决定是否释放内存。
    * 例如字符串常量可以用一个类内结构体用作计数，每次调用构造函数时，先通过结构体更新计数信息，如果已经存在该字符串的话就只计数，不分配内存。
    * 需要引入写时复制操作，也就是如果判断出程序对串中内容进行修改时，就必须要单独辟块内容出来存储作他用，除非他是最后一个指向它的对象。
    * 在这里就要区别读写操作了，可以引入一个可共享的字段，用来表哦这个字段是否可以被共享，如果被索取`operator[]`了，就把这个字段修改。
    * 还可以设计一个虚基类专用来计数。也可以用另一种类（代理类）来用辅助判断是否进行写操作，也就是延迟决策，根据后续的用户函数调用情况来区别。
 
 省略了好多内容，估计面试碰到的概率很低，总之，好书！
 ***
 
 # C++的新特性
 
 * 命名空间，`bool`，`mutable`，`explicit`，`enums`，在类内为常静态变量赋初值。
 * 模板类的弹性
 * 异常处理
 * 内存分配，也就是可重载`operator new[]`之类的操作符。
 * 各种转型操作
 * 支持string
 * 支持i/o
 * 各种容器和算法