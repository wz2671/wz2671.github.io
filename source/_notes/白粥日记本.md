---
title: 白粥日记本
date: 2021-10-24 12:58:26
tags: 
---

摘要：白粥日记本开发记录

<!--more -->

# IOS 日记app开发

<font color="#999AAA">
之前用的粉粉日记太辣鸡了，不仅越来越臃肿同步还要收费，并且还没有离线备份迁移等功能，干脆自己做个可以同步的app，省的受限于人。

***
### 日记备份

首先需要把自己的日记备份下。

已经写了好几百条的日记，自己手动备份当然不太现实，通过琢磨它的数据库把日记导了出来。

* 目前只在安卓平台下的数据进行了测试，可能只适用于当前的app版本，若之后功能进行了大的变动，只能另觅他法了。同时采用app版本为`v7.87`
* 原理其实贼简单，日记的离线数据库存储在了`xiaoxiaotu/dbfolder`目录下，其中的`*.db`中就保存着我们写的日记，只需要解析并保存出来即可。

***

### 解析数据库文件

安卓平台下，在<kbd>文件管理</kbd>中可以轻而易举地找到app的程序资源目录`xiaoxiaotu`，数据库文件在`dbfloder`下。里面就是存储着我们日记的数据库文件。
这些`*.db`文件应是app备份的文件，里面的内容并可能不是最全最新的。
取出内容的方法也非常简单。只要使用`sqlite3`进行查表即可。
```python
# -*- coding: utf-8 -*-
import sqlite3

if __name__ == '__main__':
	# 假设在目录下有一个111111111.db的文件
    demo = sqlite3.connect('xiaoxiaotu//dbfolder//111111111.db')
    cur = demo.cursor()
    # 这个命令可以查出该数据库中的所有表名
    cur.execute("SELECT name FROM sqlite_master WHERE type='table'")
    result = cur.fetchall()
    # 经检验，日记存放在了名为diary的表中，直接全取出来
    cur.execute('SELECT * from diary')
    # 取出的diary_result中就是一条条的日记信息的列表了
    diary_result = cur.fetchall()
    # 将它写入`export.txt`文件中
    with open('export.txt', 'w', encoding='utf-8') as f:
        for line in diary_result:
            f.write(line[1] + '\n\n')
            f.write('*' * 50 + '\n\n')		# 添加分割线
```

至此，日记就保存到了`export.txt`文件中了。没有任何的加密或复杂逻辑，如此索然无味。

***

### 日记app开发

从github上逛了一圈采用了一个项目(tiny-diary)[https://github.com/ImEric/Tiny-Diary]作为基础，项目比较古老了，顺利的话，应该只需要改改接口即可。

大多数基于`UIKit`的接口可以比较轻松通过编辑器自动`fix`(`Editor=>Fix All Issues`)来修复，日历用的第三方库由于太过久远，直接弃用了。之后就是学习相关开发知识，自学并完善功能。


比较实用的[UIKit教学视频](https://www.bilibili.com/video/BV1qJ411B7G3?p=1)

个人觉得比较好用的[swift5教程](https://www.bilibili.com/video/BV144411C7Gg)


### 相关知识点

* 按钮按下的事件监听的方式应采用`#selector(self.xxx(Sender:))`的方式

* `Stroyboard`的拆分可以在`Editor=>Refactor to Storyboard`，但据说ios9下不支持。

* `ViewController`可以与实现的类绑定，以实现逻辑。

* `extension DemoViewController {}`可以将一个类中不太相关的逻辑拆分在不同的部分。

* 如果某个控件我们需要做许多相同的逻辑，可以实现该控件的便利构造函数，来自定义扩展。例：
    ```swift
    extension UIBarButtonItem {
        convenience init(imageName: String, highImageName: String = "", size: CGSize = CGSizeZero)
        {
            ...
            self.init(customView: btn)
        }
    }
    ```

* `View`可以看作一个可以添加控件的容器。


***
### 踩坑

* 遇到了一个`TableViewController`中的`cell`无法显示的问题，通过debug检查发现`cell`的数据以及`view`都是ok的，最后发现问题是，需要在`storyboard`中的`TabelView`里加入元素，并拖动它的大小才能正常显示。

* 如果改了数据库中的字段`*.xcdatamodeld`中的字段之类，再次启动时会报错。
    ```
    the entity DiaryEntry is not key value coding-compliant for the key "tag".'
    ```
    解决方法： 把app删了重装即可。

* 想做一个`ViewController`，在点击某个格子的时候进行跳转，但是一直遇到以下报错:
```log
*** Terminating app due to uncaught exception 'NSInternalInconsistencyException', reason: '-[UIViewController _loadViewFromNibNamed:bundle:] loaded the "DiaryDetialView" nib but the view outlet was not set.'
terminating with uncaught exception of type NSException
```
参考[stackoverflow](https://stackoverflow.com/questions/4763519/loaded-nib-but-the-view-outlet-was-not-set)上讨论，采用了在`didSelectRowAt`的方法里手动调用`performSegue`接口实现页面跳转功能，<font color=red>**辣鸡xcode! 辣鸡swift!**</font>
```swift
func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) 
{
    selectedIndexPath = indexPath
    self.performSegue(withIdentifier: "detialSegue", sender: self)
}
```

* 想给`TabBarItem`做些动画，遇到了某些问题，正确的操作流程应如下：
    * 点击的时候根据索引，找到对应的`TabBarItem`和`UIImageView`，再设置对应的动画
    * `TabBarItem`并不包含显示的视图，需要额外去取
    * 如果是动态添加的`TabBarItem`，那么一开始可能无法取到，只能每次点击的时候遍历定位到对应的`View`再执行动画

* 整服务端的时候，在本地起了个`"localhost"`的服务器，用内网ip死活访问不了。
    * 和朋友沟通发现，原来是本地有多个网卡，`"localhost"`并不能辨别具体监听的哪个网卡，应绑定`"0.0.0.0"`来监听。

* 又发现外网ip死活也访问不了，路由器加了端口映射也不行。
    * 一番探查，原来我住的地方是内网中的内网，路由器的ip本来就是内网ip，房东家里不知道整了多少层，淦！
    * 最后采用的策略是，在本地局域网进行调试，调试完毕后就部署到租的腾讯云服务器上提供服务。

* 想要解决任务间依赖关系，可以有以下方法：[参考](https://www.bilibili.com/video/av327659651/)
    * 使用`dispatch_group_leave`和`dispatch_group_enter`接口
    * 使用`BlockOperation().addDependency`和`OperationQueue().addOperation`接口

* 多线程的一种创建和销毁方法：[参考](https://www.bilibili.com/video/av327659651/)


***

服务端搞定之后，还是先深入学习一下swift语言常用的设计方式

* `swift`也具有生成器：[参考](http://machinethink.net/blog/mixins-and-traits-in-swift-2.0/)
    ```swift
    let array = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
    var g = array.generate()

    let onlyOddNumbers = g.dropIf { i in i % 2 == 0 }
    // [1, 3, 5, 7, 9]
    ```

* 面向协议的`MVVM`架构：[参考](https://juejin.im/entry/59b9ee5f6fb9a00a402dd142?utm_source=gold_browser_extension)
    1. 使用协议，代替继承，用值传递代替引用传递
    2. 使用（实现了）协议实例化的对象，可以简化参数个数
    3. 配合`ViewModel`使用，可以几乎不用动用`view`相关的代码
    4. 将各种各样的功能，抽象成协议，通过实现这些协议，就能直接具有这样的功能，达到一个`mixin`的效果
    ```swift
    class SwitchWithTextTableViewCell: UITableViewCell {
        func configure(withDelegate delegate: SwitchWithTextCellProtocol)
        {
            // 在这里配置方法
        }
    }

    struct MinionModeViewModel: SwitchWithTextCellProtocol {
        var title = "Minion Mode!!!"
        var switchOn = true

        var switchColor: UIColor {
            return .yellowColor()
        }

        func onSwitchToggleOn(on: Bool) {
        }
    }

    // YourViewController.swift
    let cell = tableView.dequeueReusableCellWithIdentifier("SwitchWithTextTableViewCell", forIndexPath: indexPath) as! SwitchWithTextTableViewCell
    // 只要是实现对应的viewModel，即可在不动用viewController和View的情况下，调整view的显示
    cell.configure(withDelegate: MinionModeViewModel())  
    return cell
    ```

* `MVVM`模式简介：[参考](https://www.objc.io/issues/13-architecture/mvvm/)
    * `ViewModel`处理的是“表示逻辑”，例如将`Model`中的值转换为视`View`可以呈现的内容。
    * 本文主要说的就是，将`Model`的处理逻辑，迁移至`ViewModel`中。

* `MVVM`模式：[参考](https://artsy.github.io/blog/2015/09/24/mvvm-in-swift/)
    * > Models don't talk to anybody (same as MVC).  
        View models only talk to models.  
        View controllers can't talk to models directly; they only interact with view models and views.  
        Views only talk to the view controllers, notifying them of interaction events (same as MVC).
    * 总结而言，就是如何根据`Model`显示`View`是由`ViewModel`决定，`ViewController`无权访问`Model`中的数据。最终`View`收到交互事件后，会通知`ViewController`更新。

* 有一个常见的核心问题：`ViewModel`更新数据`Model`之后，如何告知`ViewController`？
    * > Use (dynamic) properties on the view model, which can be observed using KVO (or wrapped in a signal/sequence using FRP).  
        Use signals/sequences/futures as properties on the view model, which can be consumed by their corresponding async frameworks.
    * 第一种是在`ViewModel`中利用动态属性。第二种是在`ViewModel`中使用信号队列之类，然后用异步框架消费这些信号。
    * 文中提供的解决思路大致为：用`RACSignal`属性（来存储信号？）
    * 对于处理用户交互行为，采用的思路大致为：
        1. 在`ViewContrller`中创建一个闭包。
        2. 创建`ViewModel`的时候，将`ViewController`的闭包传入作为成员变量。
        3. 收到用户事件后，调用`ViewController`中的一个回调，告诉`ViewModel`具体事件。
        4. `ViewModel`查询具体的`Model`数据，将`Model`作为参数传入那个闭包。


***

网上一个质量比较高的开源的教程项目[today_news](https://github.com/hrscy/TodayNews)

## 今日头条代码阅读

模块阅读
### 各种`ViewController`
* `HomeViewController`: 这部分应该是主页的主要部分。
    * 属性：
        * 包含`SGPageTitleView`(用来显示标题)，`SGPageContentView`(显示内容)，这两个，主要是处理导航栏下面的一些频道子项(推荐之类)可滑动的那部分，左右滑动时子项也跟着滑动
        * `HomeNavigationView`自定义导航栏（包括搜索，相机，人头那三部分）
        * `addChannelButton`一个小小的添加按钮（在子项列表那儿）
    * 方法：
        * 在`viewWillAppear`接口中会设置主题之类（可能和夜间模式相关） 
        * 在`setupUI`接口中，设置各种`View`和`ViewController`，初始化各种子视图和子控制器
* `TeMaiViewController`(特卖): 在`viewDidLoad`下，创建了一个`webView`传入一个配置对象，并`load`一个`url`请求
* `HomeTableViewController`: 这部分应该是显示的所有新闻的主`View`
    * 它是用来作为几个控制器的基类`HomeRecommendCOntroller`,`HomeImageViewController`, `HomeJokeViewController`, `VideoTableViewController`等的基类，这些子类，也就是`HOmeViewController`中`switch..case`之中创建的各个子控制器
    * 属性：
        * `NewsModel`存储新闻数据的地方，是个结构体
        * `BMPlayer`用来播视频的
        * `HomeNewsTitle`新闻标题，也是个结构体，各种类别组合属性
        * `tableView`有两个属性`mj_header`和`mj_footer`是处理上拉刷新逻辑之类(参考`MJRefreshHeader`)
* `HomeRecommendController`推荐模块会在注册具体的`cell`，并根据数据来实现具体某个`cell`的显示
    * `cellForRowAt`会根据数据类型创建不同的`cell`模样
    * `didSelectRowAt`会处理跳转至详情(并提供了好多种跳转操作参考)

* `NewsDetailImageController`用来显示详情的一个控制器
    * 属性：
        * `NewsDetailImage`也是一个结构体，和图像相关的一些数据
        * `NewsModel`只有一个新闻的`Model`
    * 方法：
        * `setupUI`方法中,只看到了评论个数相关的逻辑，其他页面相关的内容可能设置在`NewsDetailImageCell`之中。


* `RefreshHeader`是处理下拉刷新的逻辑，感觉可以参考参考

***

网络
`NetworkTool`好多操作是传了一堆代码到参数里？
```swift
NetworkTool.loadApiNewsFeeds(category: category, ttFrom: .pull, {
    if self!.tableView.mj_header.isRefreshing { self!.tableView.mj_header.endRefreshing() }
    self!.player.removeFromSuperview()
    self!.maxBehotTime = $0
    self!.news = $1
    self!.tableView.reloadData()
})
```


### TODO:(还需要继续深入看的部分)
[ ] `NetworkTool.loadHomeNewsTitleData`的具体使用
[ ] 在`HomeViewController`的`setupUI`接口之中`_ = $0.compactMap({ (newsTitle) -> () in`以及`$0`的操作是何意？
[ ] 在`HomeNavigationView`中`didSelecteSerchButton`等之类的按钮点击相应好像有点意思，具体实现在`HomeViewController`的`clickAction`之中实现
[ ] 继续看下`NewsDetailImageController`和`NewsDetialImage`,`WendaViewController`, `HOmeCell`


### 总结
* 代码结构十分清晰明确，实现简洁优美，之后可以作为主要参考
* `Model`就是个结构体，不具有复杂逻辑和业务
* `ViewController`负责了主要的业务逻辑操作，各种按钮点击响应也是在这儿实现的
* `View`负责的逻辑也是特别少的,主要是设置一下布局和配色，可能有少数按钮相应接口