

帧同步

c++

### 红黑树
三种插入情况需要改（插入位置连续两个红色）
1. 没有兄弟的红色节点，从外侧插入
    一次单旋转，改变插入元素的颜色就好
2. 没有兄弟的红色节点，从内侧插入
    两次旋转，改变多个节点的颜色
3. 比较复杂的情况，有兄弟红色节点
    单旋转完之后，判断节点是否为连续红，如果为红持续网上进行当前的调整

树的深度遍历和广度遍历
哈希表
跳表
虚表 虚指针初始化时机
智能指针
python gc
优先队列
动态编译和静态编译

tcp和udp


### i/o复用:
主要针对情况，应对连接数很多情况下，侦听描述符就绪的性能问题。
传统使用多线程或多进程处理多个连接的情况，连接数稍微多点，浪费额外的资源且切换时消耗会逐渐变大，因此出现了i/o多路复用，使用一个线程的一个进程来处理多个连接。
必然要使用非阻塞socket。直接轮询就是浪费资源，使用select和poll可以在有IO事件时通知过来，但是他们都是采用轮询的方式，用户编写时，需要遍历去轮询检查数据，连接数多了之后，可能有很多无效的轮询。
select，有最大的限制1024，轮询所有描述符，存在数据拷贝问题
poll，和select类似
epoll，没有最大限制，把有事件的连接抛出来，用户可以直接逐个处理。
它只包含三个接口:
1. 创建epoll专用描述符(`epoll_create`)，只有一个参数，文件描述符的个数
2. 设置描述符关注的事件(`epoll_ctl`)，第二个参数表示 更新啥操作，可以添加描述符，删除和修改描述符事件；第三个参数时文件描述符；第四个参数是epoll_event，指明了描述符具体监听的事件
3. 等待事件的发生，如描述符可读，可写，紧急数据，连接关闭

边缘触发：事件发生时，只通知一次，要自己处理好，(有一个标志，也可以判断读到的大小是否不等)
水平触发：数据未处理完会一直通知
* 设置方式，通过`epoll_event`对象的`events`来设置
    ```c++
    epoll_event ev;
    ev.data.fd = fd;
    ev.events  = EPOLLOUT | EPOLLET; // 演示LT模式和ET模式的区别
    ```

### g66大世界实现
SererWorld
Stub

[动态链接库](https://zhuanlan.zhihu.com/p/130871341)