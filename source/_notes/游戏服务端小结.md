---
title: 游戏服务端小结
date: 2021-10-24 12:58:26
tags: 
---

摘要：此处简要整理一下，工作中的收获
[网络同步和网络架构](https://mp.weixin.qq.com/s/8YsMcKFKPRFrmiPMlsyKZg)

<!--more -->

* 游戏服务端与互联网服务端的区别?
* 为什么使用udp?
* 网络模块的基础：1. 网络通信，使用tcp或kcp等可靠的协议实现可靠的通信模块。2. 序列化与反序列化，保证服务端与客户端的数据可以通过网络通道进行可靠的数据传输。
* 双端通信的协议：客户端与服务端互相理解双方数据的方法，个人觉得，在此基础上的都是应用层的协议了，例如http协议，rpc过程调用，甚至包括自己随心所欲实现的通信方式。
* 虚拟机容器的作用：1. 使得服务端运行的环境变得可以随身携带，轻易部署。2. 使得单机可以部署许多服务，提高了硬件的使用效率。
* linux环境需要比较熟悉，各种命令和原理都应理解，如：权限，文本分析，环境变量，网络模块，shell脚本，存储，进程线程，其中通信模块应当深入学习。
* 分布式架构相关知识：保证服务器的可靠性，可扩展性，容灾能力，安全性等。目前见到的方式都挺朴素的。
* 存储相关：cap理论，sql与nosql，主从同步，索引，mongodb，redis数据结构，事务。
* 微服务与游戏服区别和使用场景，微服务的服务注册发现，服务降级和熔断，服务部署，反向代理等

***
* 游戏的账号系统，顶号流程和断线重连流程。
* 多服和跨服结构下的流程，玩家数据存档方式，服务器划分，服务器切换流程，数据迁移方式。
* 协程框架。
* 游戏内网络同步框架。


@2022/4/21
准备润了，回顾和整理一下

s2多人联机战斗分享
1. 介绍了graph的设计，这部分是离表现最近的，**核心是为了控制姿态和位移的并行计算**，项目分为了5层graph，从底往上分别为：
    环境感知（例如检查梯子，抛出事件供脚本处理），MotionInfo（输出位移，如引力场，寻路），LocoMotion（基础移动，和姿态开始相关，例如走跑等，同时也会输出位移），Action（互斥姿态控制层，技能、受击、死亡动画之类），弱表现控制层（例如弱受击，叠加姿态到整体）  
    用于先行做表现也比较方便
2. 技能系统，使用timeline编辑，加上各种逻辑业务实现相关需求
3. 使用状态机进行rpc一致性同步，里面涉及的一个问题就是上行下行控制消息可能会有冲突，需要逐个确认或者回退
4. 使用高级指令进行战斗同步，这个主要解决的是，弱网络下，使用影子跟随可能拉扯会比较严重。这个方案是服务端客户端各自根据这个指令进行控制和表现，对于结果不一致和误差，会进行修复使得结果近似。（找合适的时机悄悄修正，例如浮空）
5. 战斗结算，单人pve，多人pve，pvp；分别采用不同的碰撞检测和结算方法，越往后越严

***
### mongodb
* 反范式化可以减少额外查询次数，但可能导致数据不一致，对于更新频率很低的数据，可以采用此种方式。
* 对文档大小修改会很费性能，最好不要频繁新加数据，可以预先分配好空间，用垃圾数据填充一下
* 尽量不要让mongodb跑脚本做计算任务，性能很低，最好存进去的时候直接已经算好，或者拿再做额外计算
* 复合索引可以被多个查询（部分）使用，甚至可以直接覆盖一些简单的查询。
* 执行命令的本质也是一个查询，并且命令也是一种集合`$cmd`

### 网络编程教程（陈硕）
* NTP协议，用来校准时钟，方法：`((T1 + T4) - (T2 + T3)) / 2`，其中`T1`表示客户端发送请求的时间，`T2`表示服务端接收到请求的时间，`T3`表示服务端响应的时间，`T4`表示客户端收到响应的时间。求出的结果即为客户端与服务端的时间差，校准时应当缓慢的校准，不宜突变，否则会产生震荡，校准的是**频率**，这样子才能保证越来越准。[算法](https://www.eecis.udel.edu/~mills/precision.html)
* 他在本机上测试了一波，大致结论是，本机与本机的时钟差异大概几微秒，但是请求的一个来回时间比较大，大概有0.x毫秒（**本机网络协议栈一个来回花费的时间大约0.1毫秒**），在没有运行NTP的情况下，两台机器的时间差距大概有3毫秒。如果对延迟比较敏感，最好采用同进程里信号量交换的方式，以太网的延迟还挺高。
* 他在第16讲详细讲了UTC时间和UnxiTime的区别，指出了瑞秒（由于地球变慢修正的时间）带来的两个问题：1. 股票交易时时间可能会跳。2. 各种代码难以处理时间为负的情况，且难以测试，易导致那个时刻出现大bug。有一个解决方法，是使用三角函数`cos`来模拟时间，保证时间连续且导数频率也连续。
* `netcat`比较高级的命令

* 如果些程序发完数据直接关闭socket，会使用RST关闭连接，会导致缓冲区的数据可能未被发完，从而客户端无法接收到完整的数据；安全的做法，服务端关闭写操作`stream->shtudownWrite()`，并且一直读数据，直到返回0`(stream->receiveSome(buf, sizeof buf) > 0)`表示遇到了EOF，此时关闭socket是安全的
    1. correct sender: send() + shutdown(WR) + read()->0 + close()
    2. correct receiver: read()->0 + if nothing more to send + close()
* `SIGPIPE`如果向一个已经关闭的连接写数据会收到该信号。会导致服务端crash，可以初始化时设置忽略，但是要自己手动处理被关闭的情况。
* `Nagle's algorithm, TPC_NODELAY`如果已经发了数据，在未收到响应之前发数据，会等到收到响应ACK了才发送，会导致下次发送的数据延迟一个RTT。推荐关闭该选项。
    ```shell
    # 使用tcpdump可以看到消息来往的情况
    sudo tcpdump -i eth3 -n tcp port 3210
    ```
* `SO_REUSEADDR`选项，可以让tcp服务器在crash时立即重启（防止不能在原来的端口监听）
* select使用事件循环，要使用非阻塞io来处理，检查是否可读不能解决阻塞问题，会有以下两种情况：
    1. 当有新的连接显示可读时，如果尝试调用`accept`，可能客户端已经断开连接导致阻塞。
    2. linux可能有bug，有可能会告诉会阻塞的描述符为可读状态。
* select, poll, epoll（还要多看看）
    边缘触发：适用于发送数据和接收连接，用事件来触发。 一次性的，触发了但数据没处理完不会再触发。
    水平触发：使用于接收数据（没有新数据到来不会通知可读。