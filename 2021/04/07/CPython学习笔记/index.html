<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>CPython学习笔记 | Wenzhou&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="参考资料youtube视频百度云(提取码：2twh)python2.7源码链接 （但本文中的python代码都是基于python3环境测试的）">
<meta property="og:type" content="article">
<meta property="og:title" content="CPython学习笔记">
<meta property="og:url" content="http://yoursite.com/2021/04/07/CPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="Wenzhou&#39;s blog">
<meta property="og:description" content="参考资料youtube视频百度云(提取码：2twh)python2.7源码链接 （但本文中的python代码都是基于python3环境测试的）">
<meta property="og:locale">
<meta property="og:image" content="http://yoursite.com/images/cover/cpython.jpg">
<meta property="og:image" content="http://yoursite.com/images/cpython/frame_and_function.png">
<meta property="article:published_time" content="2021-04-07T15:44:47.000Z">
<meta property="article:modified_time" content="2021-09-22T14:17:42.203Z">
<meta property="article:author" content="WenZhou">
<meta property="article:tag" content="python笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/cover/cpython.jpg">
  
    <link rel="alternate" href="/atom.xml" title="Wenzhou's blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/images/wz.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Wenzhou&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Buscar"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Buscar"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-CPython学习笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/07/CPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2021-04-07T15:44:47.000Z" itemprop="datePublished">2021-04-07</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      CPython学习笔记
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <!-- <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Bytes-in-the-Machine-Inside-the-CPython-interpreter"><span class="toc-text">一、Bytes in the Machine Inside the CPython interpreter</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-python-interpreter-python%E8%A7%A3%E9%87%8A%E5%99%A8"><span class="toc-text">1. python interpreter (python解释器)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lecture-1-Interpreter-and-source-code-overview"><span class="toc-text">Lecture 1. Interpreter and source code overview</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-python%E8%A7%A3%E9%87%8A%E5%99%A8%E8%AF%B4%E6%98%8E"><span class="toc-text">1. python解释器说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%BA%90%E7%A0%81%E6%A6%82%E8%A7%88"><span class="toc-text">2. 源码概览</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lecture-2-Opcodes-and-main-interpreter-loop"><span class="toc-text">Lecture 2. Opcodes and main interpreter loop</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-compile%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0"><span class="toc-text">1. compile内置函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-PyEval-EvalFrameEx"><span class="toc-text">2. PyEval_EvalFrameEx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-dis%E6%A8%A1%E5%9D%97"><span class="toc-text">3. dis模块</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lecture-3-Frames-functions-calls-and-scope"><span class="toc-text">Lecture 3. Frames, functions calls, and scope</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-Frames"><span class="toc-text">1. Frames</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lecture-4-PyObject-The-core-Python-object"><span class="toc-text">Lecture 4. PyObject The core Python object</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%9C%A8python%E4%B8%AD%E4%B8%87%E7%89%A9%E7%9A%86%E5%AF%B9%E8%B1%A1"><span class="toc-text">1. 在python中万物皆对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lecture-5-Example-Python-data-types"><span class="toc-text">Lecture 5. Example Python data types</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-stringobject"><span class="toc-text">1. stringobject</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lecture-6-Code-objects-function-objects-and-closures"><span class="toc-text">Lecture 6. Code objects, function objects, and closures</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-function-object"><span class="toc-text">1. function object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-funcobject"><span class="toc-text">2. funcobject</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-closures%EF%BC%88%E9%97%AD%E5%8C%85%EF%BC%89"><span class="toc-text">3. closures（闭包）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lecture-7-Iterators"><span class="toc-text">Lecture 7. Iterators</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-text">1. 迭代器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lecture-8-User-defined-classes-and-objects"><span class="toc-text">Lecture 8. User-defined classes and objects</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-class"><span class="toc-text">1. class</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Lecture-9-Generators"><span class="toc-text">Lecture 9. Generators</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-text">1. 生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-YIELD-VALUE"><span class="toc-text">2. YIELD_VALUE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-genobject%E7%94%9F%E6%88%90%E5%99%A8%E5%AF%B9%E8%B1%A1"><span class="toc-text">3. genobject生成器对象</span></a></li></ol></li></ol></li></ol> -->
        <p><a target="_blank" rel="noopener" href="https://pg.ucsd.edu/cpython-internals.htm">参考资料</a><br><a target="_blank" rel="noopener" href="https://www.youtube.com/playlist?list=PLzV58Zm8FuBL6OAv1Yu6AwXZrnsFbbR0S">youtube视频</a><br><a target="_blank" rel="noopener" href="https://pan.baidu.com/s/1SmWNpCrY3kfiKDxAdI8roA">百度云(提取码：2twh)</a><br><a target="_blank" rel="noopener" href="https://www.python.org/ftp/python/2.7.18/Python-2.7.18.tgz">python2.7源码链接</a></p>
<p>（但本文中的python代码都是基于python3环境测试的）</p>
<p><img src="/images/cover/cpython.jpg" alt="cpython"></p>
<span id="more"></span>

<h1 id="一、Bytes-in-the-Machine-Inside-the-CPython-interpreter"><a href="#一、Bytes-in-the-Machine-Inside-the-CPython-interpreter" class="headerlink" title="一、Bytes in the Machine Inside the CPython interpreter"></a>一、Bytes in the Machine Inside the CPython interpreter</h1><h3 id="1-python-interpreter-python解释器"><a href="#1-python-interpreter-python解释器" class="headerlink" title="1. python interpreter (python解释器)"></a>1. python interpreter (python解释器)</h3><ul>
<li>python 执行代码时会分为四个阶段<ol>
<li>Lexing (词法分析)</li>
<li>Parsing (句法分析) 包括上一步，所做的事情是将Python源码分析成抽象语法树(AST)</li>
<li>Compiling 将抽象语法树转换成字节码，只做的一小部分事情</li>
<li>Interpreting 解释器会执行字节码的逻辑</li>
</ol>
</li>
<li>python 虚拟机是堆栈机(stack machine)，并不会读写各种内存，而是基于堆栈执行</li>
<li><code>BYTECODE</code>字节码通常被称为python代码的中间表示形式</li>
<li>一个求余的示例  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">mod</span>(<span class="params">a, b</span>):</span></span><br><span class="line"><span class="meta">... </span>    ans = a % b</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> ans</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(mod)</span><br><span class="line"><span class="number">2</span>           <span class="number">0</span> LOAD_FAST                <span class="number">0</span> (a)</span><br><span class="line">            <span class="number">2</span> LOAD_FAST                <span class="number">1</span> (b)</span><br><span class="line">            <span class="number">4</span> BINARY_MODULO</span><br><span class="line">            <span class="number">6</span> STORE_FAST               <span class="number">2</span> (ans)</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>           <span class="number">8</span> LOAD_FAST                <span class="number">2</span> (ans)</span><br><span class="line">            <span class="number">10</span> RETURN_VALUE</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></li>
<li>以上字节码中，最左边的数字（2, 3）表示在源码中的行数，第二列表示字节码中第几位，第三列表示的是字节码的通俗名字，第四列是表示参数的序号，第五列表示参数名。</li>
<li><code>LOAD_FAST</code>会将后面的变量压入栈中，<strong>注意</strong>，求余运算<code>BINARY_MODULO</code>本身是不需要参数的，因为参数全都在栈里了。</li>
<li>这儿的栈与调用栈并不是同一概念，每个调用栈被成为<code>frame</code>，数据栈存在了调用栈中，<code>RETURE_VALUE</code>语句，就是将数据从一个<code>frame: mod</code>中传入<code>frame: main</code>中。</li>
<li>python 虚拟机<ul>
<li>A collection of frames</li>
<li>Data stacks on frames</li>
<li>A way to run frames</li>
</ul>
</li>
<li>python 解释器原来主要是一个超大的<a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/8d21aa21f2cbc6d50aab3f420bb23be1d081dac4/Python/ceval.c#L1211"><code>switch...case...</code></a>，根据各个操作码执行相应的逻辑。</li>
<li>例如<code>LOAD_FAST</code>和<code>BINARY_MODULO</code>cpython实现  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">case</span> <span class="title">TARGET</span><span class="params">(LOAD_FAST)</span>: </span>&#123;</span><br><span class="line">    PyObject *value = GETLOCAL(oparg);</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        format_exc_check_arg(tstate, PyExc_UnboundLocalError,</span><br><span class="line">                                UNBOUNDLOCAL_ERROR_MSG,</span><br><span class="line">                                PyTuple_GetItem(co-&gt;co_varnames, oparg));</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    Py_INCREF(value);</span><br><span class="line">    PUSH(value);        <span class="comment">// 会将数据压至数据栈中</span></span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">case</span> <span class="title">TARGET</span><span class="params">(BINARY_MODULO)</span>: </span>&#123;</span><br><span class="line">    PyObject *divisor = POP();</span><br><span class="line">    PyObject *dividend = TOP();</span><br><span class="line">    PyObject *res;</span><br><span class="line">    <span class="comment">// 这儿本质类似于类型检查</span></span><br><span class="line">    <span class="keyword">if</span> (PyUnicode_CheckExact(dividend) &amp;&amp; (</span><br><span class="line">            !PyUnicode_Check(divisor) || PyUnicode_CheckExact(divisor))) &#123;</span><br><span class="line">        <span class="comment">// fast path; string formatting, but not if the RHS is a str subclass</span></span><br><span class="line">        <span class="comment">// (see issue28598)</span></span><br><span class="line">        res = PyUnicode_Format(dividend, divisor);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res = PyNumber_Remainder(dividend, divisor);</span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(divisor);</span><br><span class="line">    Py_DECREF(dividend);</span><br><span class="line">    SET_TOP(res);</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">goto</span> error;</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>如果python只有一个数据栈，那么生成器的特性就无法实现</li>
<li>由于<code>python</code>的动态类型特性，想要进一步地优化性能是一件很困难的事情，在python2中大多数是个大大的<code>switch...case...</code>，在python3中会有部分优化，源码中的部分说明如下：大致意思是，会根据cpu流水线的feature，进行优化。  <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Computed GOTOs, or</span></span><br><span class="line"><span class="comment">    the-optimization-commonly-but-improperly-known-as-&quot;threaded code&quot;</span></span><br><span class="line"><span class="comment">using gcc&#x27;s labels-as-values extension</span></span><br><span class="line"><span class="comment">(http://gcc.gnu.org/onlinedocs/gcc/Labels-as-Values.html).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">The traditional bytecode evaluation loop uses a &quot;switch&quot; statement, which</span></span><br><span class="line"><span class="comment">decent compilers will optimize as a single indirect branch instruction</span></span><br><span class="line"><span class="comment">combined with a lookup table of jump addresses. However, since the</span></span><br><span class="line"><span class="comment">indirect jump instruction is shared by all opcodes, the CPU will have a</span></span><br><span class="line"><span class="comment">hard time making the right prediction for where to jump next (actually,</span></span><br><span class="line"><span class="comment">it will be always wrong except in the uncommon case of a sequence of</span></span><br><span class="line"><span class="comment">several identical opcodes).</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">&quot;Threaded code&quot; in contrast, uses an explicit jump table and an explicit</span></span><br><span class="line"><span class="comment">indirect jump instruction at the end of each opcode. Since the jump</span></span><br><span class="line"><span class="comment">instruction is at a different address for each opcode, the CPU will make a</span></span><br><span class="line"><span class="comment">separate prediction for each of these instructions, which is equivalent to</span></span><br><span class="line"><span class="comment">predicting the second opcode of each opcode pair. These predictions have</span></span><br><span class="line"><span class="comment">a much better chance to turn out valid, especially in small bytecode loops.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">A mispredicted branch on a modern CPU flushes the whole pipeline and</span></span><br><span class="line"><span class="comment">can cost several CPU cycles (depending on the pipeline depth),</span></span><br><span class="line"><span class="comment">and potentially many more instructions (depending on the pipeline width).</span></span><br><span class="line"><span class="comment">A correctly predicted branch, however, is nearly free.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">At the time of this writing, the &quot;threaded code&quot; version is up to 15-20%</span></span><br><span class="line"><span class="comment">faster than the normal &quot;switch&quot; version, depending on the compiler and the</span></span><br><span class="line"><span class="comment">CPU architecture.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">We disable the optimization if DYNAMIC_EXECUTION_PROFILE is defined,</span></span><br><span class="line"><span class="comment">because it would render the measurements invalid.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="doctag">NOTE:</span> care must be taken that the compiler doesn&#x27;t try to &quot;optimize&quot; the</span></span><br><span class="line"><span class="comment">indirect jumps by sharing them between all opcodes. Such optimizations</span></span><br><span class="line"><span class="comment">can be disabled on gcc by using the -fno-gcse flag (or possibly</span></span><br><span class="line"><span class="comment">-fno-crossjumping).</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h1 id="Lecture-1-Interpreter-and-source-code-overview"><a href="#Lecture-1-Interpreter-and-source-code-overview" class="headerlink" title="Lecture 1. Interpreter and source code overview"></a>Lecture 1. Interpreter and source code overview</h1><h3 id="1-python解释器说明"><a href="#1-python解释器说明" class="headerlink" title="1. python解释器说明"></a>1. python解释器说明</h3><ul>
<li>CPython是标准的python解释器，采用c语言实现。PyPy是用python实现的；Jython是用java写的；Skulpt是用javascript写的，因此可以再网页浏览器里使用。</li>
<li>讲述了一些基本概念，xxx.py是python的源码，python解释器可以执行它并作出对应输出。而python解释器是cpython经过g++等编辑器编译出来的可执行程序，我们要研究的就是cpython的实现思路之类。</li>
<li>解释器执行的是字节码，并不是python的源码，编译成字节码的过程是个比较标准的过程，视频说不会太过关注，解释器部分才是真正python的动态之处</li>
</ul>
<h3 id="2-源码概览"><a href="#2-源码概览" class="headerlink" title="2. 源码概览"></a>2. 源码概览</h3><ul>
<li><p><a target="_blank" rel="noopener" href="https://www.python.org/ftp/python/2.7.18/Python-2.7.18.tgz">源码链接</a></p>
</li>
<li><p><code>/Include</code>目录下是所有的头文件，里面定义了所有的接口</p>
</li>
<li><p><code>/Objects</code>目录下所有的<code>.c</code>文件都对应了python中的一种对象类型，例如<code>listobject.c</code>就是对应的<code>list</code></p>
</li>
<li><p><code>/Python</code>目录下是运行时主要用的一些模块</p>
</li>
<li><p><code>/Modules</code>目录下是一些内置模块的实现如<code>import operator</code>，里面是用c语言实现的</p>
</li>
<li><p><code>/Lib</code>目录下是用python实现的一些内置模块</p>
</li>
<li><p><code>/Include/opcode.h</code>文件下定义了python中所有的操作码（字节码）例如<code>LOAD_FAST</code>之类</p>
</li>
<li><p><code>/Python/ceval.c</code>中是python的主循环所在位置，在源码的1069行起<a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/8d21aa21f2cbc6d50aab3f420bb23be1d081dac4/Python/ceval.c#L1069">line1069</a>，它是一个无限的循环，每次解释一个字节码，就会调度一次循环</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WITH_TSC</span></span><br><span class="line">        <span class="keyword">if</span> (inst1 == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/* Almost surely, the opcode executed a break</span></span><br><span class="line"><span class="comment">            or a continue, preventing inst1 from being set</span></span><br><span class="line"><span class="comment">            on the way out of the loop.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            READ_TIMESTAMP(inst1);</span><br><span class="line">            loop1 = inst1;</span><br><span class="line">        &#125;</span><br><span class="line">        dump_tsc(opcode, ticked, inst0, inst1, loop0, loop1,</span><br><span class="line">                intr0, intr1);</span><br><span class="line">        ticked = <span class="number">0</span>;</span><br><span class="line">        inst1 = <span class="number">0</span>;</span><br><span class="line">        intr0 = <span class="number">0</span>;</span><br><span class="line">        intr1 = <span class="number">0</span>;</span><br><span class="line">        READ_TIMESTAMP(loop0);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>可以随意修改cpython源码，进行编译，就能使用自己独家定制的python解释器了</p>
</li>
</ul>
<hr>
<h1 id="Lecture-2-Opcodes-and-main-interpreter-loop"><a href="#Lecture-2-Opcodes-and-main-interpreter-loop" class="headerlink" title="Lecture 2. Opcodes and main interpreter loop"></a>Lecture 2. Opcodes and main interpreter loop</h1><h3 id="1-compile内置函数"><a href="#1-compile内置函数" class="headerlink" title="1. compile内置函数"></a>1. <code>compile</code>内置函数</h3><ul>
<li>测试文件test.py  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1</span></span><br><span class="line">y = <span class="number">2</span></span><br><span class="line">z = x + y</span><br><span class="line">print(z)</span><br></pre></td></tr></table></figure></li>
<li>使用<code>compile(open(&#39;test.py&#39;).read(), &#39;test.py&#39;, &#39;exec&#39;)</code>编译该模块，返回一个<code>code object</code>。<br>  以下两部分是对应的，每个字节对应的就是一条操作码或者参数，<code>test.py</code>中的内容编译过后就是总长为28的字节数组(<code>co_code</code>)  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>compile(open(<span class="string">&quot;test.py&quot;</span>).read(), <span class="string">&quot;test.py&quot;</span>, <span class="string">&#x27;exec&#x27;</span>)</span><br><span class="line">&lt;code object &lt;module&gt; at <span class="number">0x000001A131B76190</span>, file <span class="string">&quot;test.py&quot;</span>, line <span class="number">1</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>_.co_code</span><br><span class="line"><span class="string">b&#x27;d\x00Z\x00d\x01Z\x01e\x00e\x01\x17\x00Z\x02e\x03e\x02\x83\x01\x01\x00d\x02S\x00&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[byte <span class="keyword">for</span> byte <span class="keyword">in</span> _]</span><br><span class="line">[<span class="number">100</span>, <span class="number">0</span>, <span class="number">90</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">90</span>, <span class="number">1</span>, <span class="number">101</span>, <span class="number">0</span>, <span class="number">101</span>, <span class="number">1</span>, <span class="number">23</span>, <span class="number">0</span>, <span class="number">90</span>, <span class="number">2</span>, <span class="number">101</span>, <span class="number">3</span>, <span class="number">101</span>, <span class="number">2</span>, <span class="number">131</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">100</span>, <span class="number">2</span>, <span class="number">83</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PS D:\CODE\Python-2.7.18&gt; python -m dis test.py</span><br><span class="line">1            0 LOAD_CONST               0 (1)        <span class="comment"># 这儿LOAD_CONST占一字节(100)，参数一字节，共两字节</span></span><br><span class="line">             2 STORE_NAME               0 (x)        <span class="comment"># STORE_NAME从第三字节开始(90)</span></span><br><span class="line"></span><br><span class="line">2            4 LOAD_CONST               1 (2)</span><br><span class="line">             6 STORE_NAME               1 (y)</span><br><span class="line"></span><br><span class="line">3            8 LOAD_NAME                0 (x)</span><br><span class="line">            10 LOAD_NAME                1 (y)</span><br><span class="line">            12 BINARY_ADD</span><br><span class="line">            14 STORE_NAME               2 (z)</span><br><span class="line"></span><br><span class="line">4           16 LOAD_NAME                3 (<span class="built_in">print</span>)</span><br><span class="line">            18 LOAD_NAME                2 (z)</span><br><span class="line">            20 CALL_FUNCTION            1</span><br><span class="line">            22 POP_TOP</span><br><span class="line">            24 LOAD_CONST               2 (None)</span><br><span class="line">            26 RETURN_VALUE</span><br></pre></td></tr></table></figure></li>
<li><strong>在教程中，上面说的有点问题</strong>，一开始使用<code>compile(&#39;test.py&#39;, &#39;test.py&#39;, &#39;exec&#39;)</code>实际编译的是<code>test.py</code>这条语句。(后来纠正了)</li>
<li>在<code>opcode.h</code>中，从94行<code>HAVE_ARGUMENT</code>起，下面的字节码是需要接受参数的了</li>
<li>视频里说第三列的数字表示在变量栈(value stack)里的顺序</li>
</ul>
<h3 id="2-PyEval-EvalFrameEx"><a href="#2-PyEval-EvalFrameEx" class="headerlink" title="2. PyEval_EvalFrameEx"></a>2. <code>PyEval_EvalFrameEx</code></h3><ul>
<li>是一个超长的函数<a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/8d21aa21f2cbc6d50aab3f420bb23be1d081dac4/Python/ceval.c#L688-L3364">line688-3364</a>，它就是执行python源码的主要函数，里面有个指针<code>stack_pointer</code>就是存的value stack</li>
<li>先定义了一些操作的宏定义，例如压栈出栈等  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// line[883-975]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PUSH(v)         &#123; (void)(BASIC_PUSH(v), \</span></span><br><span class="line">                        lltrace &amp;&amp; prtrace(TOP(), &quot;push&quot;)); \</span><br><span class="line">                        assert(STACK_LEVEL() &lt;= co-&gt;co_stacksize); &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> POP()           ((void)(lltrace &amp;&amp; prtrace(TOP(), <span class="meta-string">&quot;pop&quot;</span>)), \</span></span><br><span class="line">                        BASIC_POP())</span><br></pre></td></tr></table></figure></li>
<li>它的参数是<code>PyFrameObject</code>，指的是第一节中的<code>frame</code>，其中存储了各个字节码，参数等  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// line[1024-1029]</span></span><br><span class="line">co = f-&gt;f_code;         <span class="comment">// 取出frame的code_object</span></span><br><span class="line">names = co-&gt;co_names;</span><br><span class="line">consts = co-&gt;co_consts;</span><br><span class="line">fastlocals = f-&gt;f_localsplus;</span><br><span class="line">freevars = f-&gt;f_localsplus + co-&gt;co_nlocals;</span><br><span class="line">first_instr = (<span class="keyword">unsigned</span> <span class="keyword">char</span>*) PyString_AS_STRING(co-&gt;co_code);</span><br></pre></td></tr></table></figure></li>
<li>大大的循环从<code>line[1069]</code>开始<code>for (;;)</code>，其中<code>WITH_TSC</code>指的是<code>Timestamp counter</code>，用来评估程序跑的有多快。</li>
<li>从<code>line[1211]</code>行起，就是大大的<code>switch...case...</code>，分别遍历每个操作符，并执行对应的操作，循环结束的部分如下所示，会跳到<code>fast_block_end</code>部分  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// line[2100-2105]</span></span><br><span class="line">TARGET_NOARG(RETURN_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">    retval = POP();</span><br><span class="line">    why = WHY_RETURN;</span><br><span class="line">    <span class="keyword">goto</span> fast_block_end;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// line[2852-2856]</span></span><br><span class="line">TARGET_NOARG(BREAK_LOOP)</span><br><span class="line">&#123;</span><br><span class="line">    why = WHY_BREAK;</span><br><span class="line">    <span class="keyword">goto</span> fast_block_end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// line[2858-2867]</span></span><br><span class="line">TARGET(CONTINUE_LOOP)</span><br><span class="line">&#123;</span><br><span class="line">    retval = PyInt_FromLong(oparg);</span><br><span class="line">    <span class="keyword">if</span> (!retval) &#123;</span><br><span class="line">        x = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    why = WHY_CONTINUE;</span><br><span class="line">    <span class="keyword">goto</span> fast_block_end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>之后会做一些清理的工作，直到<code>line[3363]</code>行<code>return retval</code>返回结果</li>
</ul>
<h3 id="3-dis模块"><a href="#3-dis模块" class="headerlink" title="3. dis模块"></a>3. <code>dis</code>模块</h3><ul>
<li>官方文档的<code>dis</code>模块中详细说明了各个字节码的含义，具体内容可参考<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/dis.html">链接</a></li>
</ul>
<hr>
<h1 id="Lecture-3-Frames-functions-calls-and-scope"><a href="#Lecture-3-Frames-functions-calls-and-scope" class="headerlink" title="Lecture 3. Frames, functions calls, and scope"></a>Lecture 3. Frames, functions calls, and scope</h1><h3 id="1-Frames"><a href="#1-Frames" class="headerlink" title="1. Frames"></a>1. <code>Frames</code></h3><ul>
<li><p><code>PyEval_EvalFrameEx</code>是之前所说的执行字节码的主入口，他接受一个<code>PyFrameObject</code>的指针，这个指针指向的就是一个<code>frame</code>对象。</p>
</li>
<li><p>每个<code>frame</code>都包含一段可以执行的逻辑，也就是<code>code_object</code>，还有相关的运行环境如全局变量和局部变量等，它的具体定义如下所示，在文件<code>Include/frameobject.h</code>中<a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/8d21aa21f2cbc6d50aab3f420bb23be1d081dac4/Include/frameobject.h#L16-L50">line16-50</a></p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> *<span class="title">f_back</span>;</span>	<span class="comment">/* previous frame, or NULL */</span>       <span class="comment">// 存储了调用它的上一个frame</span></span><br><span class="line">    PyCodeObject *f_code;	<span class="comment">/* code segment */</span>                  <span class="comment">// 字节对象</span></span><br><span class="line">    PyObject *f_builtins;	<span class="comment">/* builtin symbol table (PyDictObject) */</span></span><br><span class="line">    PyObject *f_globals;	<span class="comment">/* global symbol table (PyDictObject) */</span></span><br><span class="line">    PyObject *f_locals;		<span class="comment">/* local symbol table (any mapping) */</span></span><br><span class="line">    PyObject **f_valuestack;	<span class="comment">/* points after the last local */</span>       <span class="comment">// 拥有一个独立的数据栈</span></span><br><span class="line">    <span class="comment">/* Next free slot in f_valuestack.  Frame creation sets to f_valuestack.</span></span><br><span class="line"><span class="comment">    Frame evaluation usually NULLs it, but a frame that yields sets it</span></span><br><span class="line"><span class="comment">    to the current stack top. */</span></span><br><span class="line">    PyObject **f_stacktop;</span><br><span class="line">    PyObject *f_trace;		<span class="comment">/* Trace function */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If an exception is raised in this frame, the next three are used to</span></span><br><span class="line"><span class="comment">    * record the exception info (if any) originally in the thread state.  See</span></span><br><span class="line"><span class="comment">    * comments before set_exc_info() -- it&#x27;s not obvious.</span></span><br><span class="line"><span class="comment">    * Invariant:  if _type is NULL, then so are _value and _traceback.</span></span><br><span class="line"><span class="comment">    * Desired invariant:  all three are NULL, or all three are non-NULL.  That</span></span><br><span class="line"><span class="comment">    * one isn&#x27;t currently true, but &quot;should be&quot;.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    PyObject *f_exc_type, *f_exc_value, *f_exc_traceback;</span><br><span class="line"></span><br><span class="line">    PyThreadState *f_tstate;</span><br><span class="line">    <span class="keyword">int</span> f_lasti;		<span class="comment">/* Last instruction if called */</span></span><br><span class="line">    <span class="comment">/* Call PyFrame_GetLineNumber() instead of reading this field</span></span><br><span class="line"><span class="comment">    directly.  As of 2.3 f_lineno is only valid when tracing is</span></span><br><span class="line"><span class="comment">    active (i.e. when f_trace is set).  At other times we use</span></span><br><span class="line"><span class="comment">    PyCode_Addr2Line to calculate the line from the current</span></span><br><span class="line"><span class="comment">    bytecode index. */</span></span><br><span class="line">    <span class="keyword">int</span> f_lineno;		<span class="comment">/* Current line number */</span></span><br><span class="line">    <span class="keyword">int</span> f_iblock;		<span class="comment">/* index in f_blockstack */</span></span><br><span class="line">    PyTryBlock f_blockstack[CO_MAXBLOCKS]; <span class="comment">/* for try and loop blocks */</span></span><br><span class="line">    PyObject *f_localsplus[<span class="number">1</span>];	<span class="comment">/* locals+stack, dynamically sized */</span>       <span class="comment">// 动态创建的一个数据栈</span></span><br><span class="line">&#125; PyFrameObject;</span><br></pre></td></tr></table></figure>
</li>
<li><p>每个函数都会对应一个<code>code_object</code>，通过编译以下代码，可以看到<code>code object</code>被存到了名为<code>func</code>的变量里了，它也包含字节码，是一段独立的可执行的逻辑</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>(<span class="params">x</span>):</span></span><br><span class="line">    a = x</span><br><span class="line">    print(<span class="number">2</span> * a)</span><br></pre></td></tr></table></figure>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PS D:\CODE\Python-2.7.18&gt; python -m dis .\test.py</span><br><span class="line">2           0 LOAD_CONST               0 (&lt;code object fun at 0x000001872E049920, file <span class="string">&quot;.\test.py&quot;</span>, line 2&gt;)</span><br><span class="line">            2 LOAD_CONST               1 (<span class="string">&#x27;fun&#x27;</span>)</span><br><span class="line">            4 MAKE_FUNCTION            0</span><br><span class="line">            6 STORE_NAME               0 (fun)</span><br><span class="line">            8 LOAD_CONST               2 (None)</span><br><span class="line">            10 RETURN_VALUE</span><br><span class="line"></span><br><span class="line">Disassembly of &lt;code object fun at 0x000001872E049920, file <span class="string">&quot;.\test.py&quot;</span>, line 2&gt;:</span><br><span class="line">3           0 LOAD_FAST                0 (x)</span><br><span class="line">            2 STORE_FAST               1 (a)</span><br><span class="line"></span><br><span class="line">4           4 LOAD_GLOBAL              0 (<span class="built_in">print</span>)</span><br><span class="line">            6 LOAD_CONST               1 (2)</span><br><span class="line">            8 LOAD_FAST                1 (a)</span><br><span class="line">            10 BINARY_MULTIPLY</span><br><span class="line">            12 CALL_FUNCTION            1</span><br><span class="line">            14 POP_TOP</span><br><span class="line">            16 LOAD_CONST               0 (None)</span><br><span class="line">            18 RETURN_VALUE</span><br><span class="line">PS D:\CODE\Python-2.7.18&gt;ash</span><br></pre></td></tr></table></figure></li>
<li><p><code>code_object</code>定义在了<code>Include/code.h</code>之中<a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/8d21aa21f2cbc6d50aab3f420bb23be1d081dac4/Include/code.h#L10-L30">line10-30</a>，具体成员变量如下所示</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Bytecode object */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="keyword">int</span> co_argcount;		<span class="comment">/* #arguments, except *args */</span></span><br><span class="line">    <span class="keyword">int</span> co_nlocals;		<span class="comment">/* #local variables */</span></span><br><span class="line">    <span class="keyword">int</span> co_stacksize;		<span class="comment">/* #entries needed for evaluation stack */</span></span><br><span class="line">    <span class="keyword">int</span> co_flags;		<span class="comment">/* CO_..., see below */</span></span><br><span class="line">    PyObject *co_code;		<span class="comment">/* instruction opcodes */</span>       <span class="comment">// 原始的操作码</span></span><br><span class="line">    PyObject *co_consts;	<span class="comment">/* list (constants used) */</span></span><br><span class="line">    PyObject *co_names;		<span class="comment">/* list of strings (names used) */</span></span><br><span class="line">    PyObject *co_varnames;	<span class="comment">/* tuple of strings (local variable names) */</span>   <span class="comment">//变量名之类</span></span><br><span class="line">    PyObject *co_freevars;	<span class="comment">/* tuple of strings (free variable names) */</span>    <span class="comment">// 自由变量</span></span><br><span class="line">    PyObject *co_cellvars;      <span class="comment">/* tuple of strings (cell variable names) */</span></span><br><span class="line">    <span class="comment">/* The rest doesn&#x27;t count for hash/cmp */</span></span><br><span class="line">    PyObject *co_filename;	<span class="comment">/* string (where it was loaded from) */</span></span><br><span class="line">    PyObject *co_name;		<span class="comment">/* string (name, for reference) */</span></span><br><span class="line">    <span class="keyword">int</span> co_firstlineno;		<span class="comment">/* first source line number */</span></span><br><span class="line">    PyObject *co_lnotab;	<span class="comment">/* string (encoding addr&lt;-&gt;lineno mapping) See</span></span><br><span class="line"><span class="comment">                Objects/lnotab_notes.txt for details. */</span></span><br><span class="line">    <span class="keyword">void</span> *co_zombieframe;     <span class="comment">/* for optimization only (see frameobject.c) */</span></span><br><span class="line">    PyObject *co_weakreflist;   <span class="comment">/* to support weakrefs to code objects */</span></span><br><span class="line">&#125; PyCodeObject;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一些概念区分:</p>
<ul>
<li><code>code_object</code>，它存储的了原始的字节码，和一些变量名之类。</li>
<li><code>function</code>持有一个<code>code_object</code>，同时拥有执行该<code>code_object</code>的环境<code>environment</code>，它时静态的数据。</li>
<li><code>frame</code>是<code>function</code>在运行时的对象，它是动态的。如下图所示，<code>fact</code>只拥有一个<code>function</code>，但是在运行时可以拥有多个<code>frame</code>，每个<code>frame</code>拥有数据自己的数据栈。<img src="/images/cpython/frame_and_function.png" alt="frame_and_function"></li>
</ul>
</li>
<li><p><code>CALL_FUNCTION</code>字节码的实现只是调用函数<a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/8d21aa21f2cbc6d50aab3f420bb23be1d081dac4/Python/ceval.c#L3005-L3019">line3005-3019</a>，具体实现在<code>call_function</code>函数里的<code>fast_function</code>中<a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/8d21aa21f2cbc6d50aab3f420bb23be1d081dac4/Python/ceval.c#L4424-L4475">line4424-4475</a>。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// line[3005-3019]</span></span><br><span class="line">TARGET(CALL_FUNCTION)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject **sp;</span><br><span class="line">    PCALL(PCALL_ALL);</span><br><span class="line">    sp = stack_pointer;             </span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> WITH_TSC</span></span><br><span class="line">    x = call_function(&amp;sp, oparg, &amp;intr0, &amp;intr1);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    x = call_function(&amp;sp, oparg);  <span class="comment">//  执行函数，获取返回值</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    stack_pointer = sp;             <span class="comment">//</span></span><br><span class="line">    PUSH(x);                        <span class="comment">// 返回结果压栈</span></span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">NULL</span>) DISPATCH();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// line[4334-4401]</span></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">call_function(PyObject ***pp_stack, <span class="keyword">int</span> oparg</span><br><span class="line">#ifdef WITH_TSC</span><br><span class="line">                , uint64* pintr0, uint64* pintr1</span><br><span class="line">#endif</span><br><span class="line">                )</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// ...略</span></span><br><span class="line">    <span class="keyword">if</span> (PyFunction_Check(func))</span><br><span class="line">        x = fast_function(func, pp_stack, n, na, nk);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        x = do_call(func, pp_stack, na, nk);</span><br><span class="line"><span class="comment">// ...略</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// line[4424]</span></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">fast_function(PyObject *func, PyObject ***pp_stack, <span class="keyword">int</span> n, <span class="keyword">int</span> na, <span class="keyword">int</span> nk)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 略</span></span><br><span class="line">        assert(tstate != <span class="literal">NULL</span>);</span><br><span class="line">        f = PyFrame_New(tstate, co, globals, <span class="literal">NULL</span>);     <span class="comment">// 这儿创建的对应frame</span></span><br><span class="line">        <span class="keyword">if</span> (f == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 以下将函数的value_stack拷贝了出来，本质上是将参数传递了过来</span></span><br><span class="line">        fastlocals = f-&gt;f_localsplus;</span><br><span class="line">        <span class="built_in">stack</span> = (*pp_stack) - n;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Py_INCREF(*<span class="built_in">stack</span>);</span><br><span class="line">            fastlocals[i] = *<span class="built_in">stack</span>++;</span><br><span class="line">        &#125;</span><br><span class="line">        retval = PyEval_EvalFrameEx(f,<span class="number">0</span>);       <span class="comment">// 此时重新调用主循环，执行刚刚创建的frame</span></span><br><span class="line">        ++tstate-&gt;recursion_depth;</span><br><span class="line">        Py_DECREF(f);</span><br><span class="line">        --tstate-&gt;recursion_depth;</span><br><span class="line">        <span class="keyword">return</span> retval;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>因此调用一个函数的流程时执行<code>CALL_FUNCTION</code>操作码，实质是创建了一个<code>FrameObject</code>交给<code>PyEval_EvalFrameEx</code>去执行。</p>
</li>
</ul>
<hr>
<h1 id="Lecture-4-PyObject-The-core-Python-object"><a href="#Lecture-4-PyObject-The-core-Python-object" class="headerlink" title="Lecture 4. PyObject The core Python object"></a>Lecture 4. PyObject The core Python object</h1><h3 id="1-在python中万物皆对象"><a href="#1-在python中万物皆对象" class="headerlink" title="1. 在python中万物皆对象"></a>1. 在python中万物皆对象</h3><ul>
<li><p>就算是<code>int</code>的变量，也是对象</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = <span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(x)</span><br><span class="line">[<span class="string">&#x27;__abs__&#x27;</span>, <span class="string">&#x27;__add__&#x27;</span>, <span class="string">&#x27;__and__&#x27;</span>, <span class="string">&#x27;__bool__&#x27;</span>, <span class="string">&#x27;__ceil__&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__divmod__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__float__&#x27;</span>, <span class="string">&#x27;__floor__&#x27;</span>, <span class="string">&#x27;__floordiv__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__getnewargs__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__index__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__int__&#x27;</span>, <span class="string">&#x27;__invert__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lshift__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__mod__&#x27;</span>, <span class="string">&#x27;__mul__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__neg__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__or__&#x27;</span>, <span class="string">&#x27;__pos__&#x27;</span>, <span class="string">&#x27;__pow__&#x27;</span>, <span class="string">&#x27;__radd__&#x27;</span>, <span class="string">&#x27;__rand__&#x27;</span>, <span class="string">&#x27;__rdivmod__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__rfloordiv__&#x27;</span>, <span class="string">&#x27;__rlshift__&#x27;</span>, <span class="string">&#x27;__rmod__&#x27;</span>, <span class="string">&#x27;__rmul__&#x27;</span>, <span class="string">&#x27;__ror__&#x27;</span>, <span class="string">&#x27;__round__&#x27;</span>, <span class="string">&#x27;__rpow__&#x27;</span>, <span class="string">&#x27;__rrshift__&#x27;</span>, <span class="string">&#x27;__rshift__&#x27;</span>, <span class="string">&#x27;__rsub__&#x27;</span>, <span class="string">&#x27;__rtruediv__&#x27;</span>, <span class="string">&#x27;__rxor__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__sub__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;__truediv__&#x27;</span>, <span class="string">&#x27;__trunc__&#x27;</span>, <span class="string">&#x27;__xor__&#x27;</span>, <span class="string">&#x27;as_integer_ratio&#x27;</span>, <span class="string">&#x27;bit_length&#x27;</span>, <span class="string">&#x27;conjugate&#x27;</span>, <span class="string">&#x27;denominator&#x27;</span>, <span class="string">&#x27;from_bytes&#x27;</span>, <span class="string">&#x27;imag&#x27;</span>, <span class="string">&#x27;numerator&#x27;</span>, <span class="string">&#x27;real&#x27;</span>, <span class="string">&#x27;to_bytes&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.__add__(<span class="number">1</span>)</span><br><span class="line"><span class="number">124</span></span><br></pre></td></tr></table></figure></li>
<li><p><code>int</code>的加法实际实现在<code>intobject.c</code>里的<code>int_add</code>中<a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/8d21aa21f2cbc6d50aab3f420bb23be1d081dac4/Objects/intobject.c#L468-L493">line468-493</a></p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// line[168-179]</span></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">int_add(PyIntObject *v, PyIntObject *w)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">long</span> a, b, x;</span><br><span class="line">    CONVERT_TO_LONG(v, a);</span><br><span class="line">    CONVERT_TO_LONG(w, b);</span><br><span class="line">    <span class="comment">/* casts in the line below avoid undefined behaviour on overflow */</span></span><br><span class="line">    x = (<span class="keyword">long</span>)((<span class="keyword">unsigned</span> <span class="keyword">long</span>)a + b);</span><br><span class="line">    <span class="keyword">if</span> ((x^a) &gt;= <span class="number">0</span> || (x^b) &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> PyInt_FromLong(x);</span><br><span class="line">    <span class="keyword">return</span> PyLong_Type.tp_as_number-&gt;nb_add((PyObject *)v, (PyObject *)w);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>sys</code>模块中过的<code>getrefcount</code>可以轻易看到引用计数。从视频中的来看，有些令人费解</p>
</li>
<li><p>在<code>object.h</code>中的注释中说，每个<code>PyObject</code>对象都拥有一个<code>reference count</code>引用计数，和<code>type</code>类型，对于<code>type</code>类型，它有一个<code>type</code>指向了自己，（也仅仅只有这两个东西）</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyObject_HEAD                   \</span></span><br><span class="line">    _PyObject_HEAD_EXTRA                \       <span class="comment">// 这个宏定义是用于调试的(Py_TRACE_REFS)</span></span><br><span class="line">    Py_ssize_t ob_refcnt;               \       <span class="comment">// 引用计数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span>                <span class="comment">// 类型指针</span></span><br><span class="line"><span class="comment">/* Nothing is actually declared to be a PyObject, but every pointer to</span></span><br><span class="line"><span class="comment">* a Python object can be cast to a PyObject*.  This is inheritance built</span></span><br><span class="line"><span class="comment">* by hand.  Similarly every pointer to a variable-size Python object can,</span></span><br><span class="line"><span class="comment">* in addition, be cast to PyVarObject*.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">&#125; PyObject;</span><br><span class="line"><span class="comment">// 宏定义编辑过后的结果就是</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">object</span> &#123;</span></span><br><span class="line">    Py_ssize_t ob_refcnt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">ob_type</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>对于<code>intobject</code>，它的定义如下(在<code>intobject.h</code>中)，相对于PyObject，多定义了一个long，其他的对象类似。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="keyword">long</span> ob_ival;</span><br><span class="line">&#125; PyIntObject;</span><br></pre></td></tr></table></figure></li>
<li><p>PyObject对象的生成与内存分配在<code>object.c</code>中的<code>_PyObject_New</code>函数中<a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/8d21aa21f2cbc6d50aab3f420bb23be1d081dac4/Objects/object.c#L240-L248">line240-248</a>。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// line[240-248] 先创建一个类型</span></span><br><span class="line">PyObject *</span><br><span class="line">_PyObject_New(PyTypeObject *tp)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *op;</span><br><span class="line">    op = (PyObject *) PyObject_MALLOC(_PyObject_SIZE(tp));</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    <span class="keyword">return</span> PyObject_INIT(op, tp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>python中对象的动态性主要来源于，对每种类型都约束其特定接口，不同类型的PyObject传入后，会执行相同名称不同接口的具体实现<a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/8d21aa21f2cbc6d50aab3f420bb23be1d081dac4/Objects/object.c#L411-L451">line411-451</a></p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如把某个类型转成字符串，通过`tp_str`接口实现的，有点像多态那味</span></span><br><span class="line">PyObject *</span><br><span class="line">_PyObject_Str(PyObject *v)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *res;</span><br><span class="line">    <span class="keyword">int</span> type_ok;</span><br><span class="line">    <span class="keyword">if</span> (v == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> PyString_FromString(<span class="string">&quot;&lt;NULL&gt;&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (PyString_CheckExact(v)) &#123;</span><br><span class="line">        Py_INCREF(v);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Py_USING_UNICODE</span></span><br><span class="line">    <span class="keyword">if</span> (PyUnicode_CheckExact(v)) &#123;</span><br><span class="line">        Py_INCREF(v);</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (Py_TYPE(v)-&gt;tp_str == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> PyObject_Repr(v);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* It is possible for a type to have a tp_str representation that loops</span></span><br><span class="line"><span class="comment">    infinitely. */</span></span><br><span class="line">    <span class="keyword">if</span> (Py_EnterRecursiveCall(<span class="string">&quot; while getting the str of an object&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    res = (*Py_TYPE(v)-&gt;tp_str)(v);     <span class="comment">// 每个类型都实现了`tp_str`的方法，去执行具体类型转化为字符串的逻辑</span></span><br><span class="line">    Py_LeaveRecursiveCall();</span><br><span class="line">    <span class="keyword">if</span> (res == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    type_ok = PyString_Check(res);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Py_USING_UNICODE</span></span><br><span class="line">    type_ok = type_ok || PyUnicode_Check(res);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (!type_ok) &#123;</span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                    <span class="string">&quot;__str__ returned non-string (type %.200s)&quot;</span>,</span><br><span class="line">                    Py_TYPE(res)-&gt;tp_name);</span><br><span class="line">        Py_DECREF(res);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>除了<code>PyObject</code>之外，附近还有一个<code>PyVarObject</code>，是用来处理一些可变变量的类型，除了<code>PyObject_HEAD</code>之外，它还额外拥有一个<code>ob_size</code>属性。因此它有三条属性：引用计数，类型，和体重。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PyObject_VAR_HEAD               \</span></span><br><span class="line">    PyObject_HEAD                       \</span><br><span class="line">    Py_ssize_t ob_size; <span class="comment">/* Number of items in variable part */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Py_INVALID_SIZE (Py_ssize_t)-1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Similarly every pointer to a variable-size Python object can,</span></span><br><span class="line"><span class="comment">* in addition, be cast to PyVarObject*.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">&#125; PyVarObject;</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>object.h</code>中还定义了<code>PyTypeObject</code><a target="_blank" rel="noopener" href="https://github.com/python/cpython/blob/8d21aa21f2cbc6d50aab3f420bb23be1d081dac4/Include/object.h#L324-L411">line324-411</a>，这个就是每个<code>PyObject_HEAD</code>中的那个<code>ob_type</code>，超核心的类型指针对应的类型。（搜<code>_typeobject</code>比较好找）</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个对象是cpython实现动态类型地关键，通过各个类型实现对应地接口，ceval可以直接拿取指针执行各自类型相应地逻辑，十分相似于多态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tp_name; <span class="comment">/* For printing, in format &quot;&lt;module&gt;.&lt;name&gt;&quot; */</span></span><br><span class="line">    Py_ssize_t tp_basicsize, tp_itemsize; <span class="comment">/* For allocation */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Methods to implement standard operations */</span></span><br><span class="line"></span><br><span class="line">    destructor tp_dealloc;</span><br><span class="line">    printfunc tp_print;</span><br><span class="line">    getattrfunc tp_getattr;</span><br><span class="line">    setattrfunc tp_setattr;</span><br><span class="line">    cmpfunc tp_compare;</span><br><span class="line">    reprfunc tp_repr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Method suites for standard classes */</span></span><br><span class="line"></span><br><span class="line">    PyNumberMethods *tp_as_number;</span><br><span class="line">    PySequenceMethods *tp_as_sequence;</span><br><span class="line">    PyMappingMethods *tp_as_mapping;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* More standard operations (here for binary compatibility) */</span></span><br><span class="line"></span><br><span class="line">    hashfunc tp_hash;</span><br><span class="line">    ternaryfunc tp_call;                <span class="comment">// 可执行函数</span></span><br><span class="line">    reprfunc tp_str;                    <span class="comment">// str(object)函数</span></span><br><span class="line">    getattrofunc tp_getattro;</span><br><span class="line">    setattrofunc tp_setattro;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Functions to access object as input/output buffer */</span></span><br><span class="line">    PyBufferProcs *tp_as_buffer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Flags to define presence of optional/expanded features */</span></span><br><span class="line">    <span class="keyword">long</span> tp_flags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *tp_doc; <span class="comment">/* Documentation string */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assigned meaning in release 2.0 */</span></span><br><span class="line">    <span class="comment">/* call function for all accessible objects */</span></span><br><span class="line">    traverseproc tp_traverse;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* delete references to contained objects */</span></span><br><span class="line">    inquiry tp_clear;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Assigned meaning in release 2.1 */</span></span><br><span class="line">    <span class="comment">/* rich comparisons */</span></span><br><span class="line">    richcmpfunc tp_richcompare;         <span class="comment">// 比较函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* weak reference enabler */</span></span><br><span class="line">    Py_ssize_t tp_weaklistoffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Added in release 2.2 */</span></span><br><span class="line">    <span class="comment">/* Iterators */</span></span><br><span class="line">    getiterfunc tp_iter;                <span class="comment">// 返回可迭代对象的迭代器</span></span><br><span class="line">    iternextfunc tp_iternext;           <span class="comment">// 返回迭代器的下一个值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Attribute descriptor and subclassing stuff */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMethodDef</span> *<span class="title">tp_methods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyMemberDef</span> *<span class="title">tp_members</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">PyGetSetDef</span> *<span class="title">tp_getset</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_base</span>;</span></span><br><span class="line">    PyObject *tp_dict;</span><br><span class="line">    descrgetfunc tp_descr_get;</span><br><span class="line">    descrsetfunc tp_descr_set;</span><br><span class="line">    Py_ssize_t tp_dictoffset;</span><br><span class="line">    initproc tp_init;</span><br><span class="line">    allocfunc tp_alloc;</span><br><span class="line">    newfunc tp_new;</span><br><span class="line">    freefunc tp_free; <span class="comment">/* Low-level free-memory routine */</span></span><br><span class="line">    inquiry tp_is_gc; <span class="comment">/* For PyObject_IS_GC */</span></span><br><span class="line">    PyObject *tp_bases;</span><br><span class="line">    PyObject *tp_mro; <span class="comment">/* method resolution order */</span></span><br><span class="line">    PyObject *tp_cache;</span><br><span class="line">    PyObject *tp_subclasses;</span><br><span class="line">    PyObject *tp_weaklist;</span><br><span class="line">    destructor tp_del;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Type attribute cache version tag. Added in version 2.6 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> tp_version_tag;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> COUNT_ALLOCS</span></span><br><span class="line">    <span class="comment">/* these must be last and never explicitly initialized */</span></span><br><span class="line">    Py_ssize_t tp_allocs;</span><br><span class="line">    Py_ssize_t tp_frees;</span><br><span class="line">    Py_ssize_t tp_maxalloc;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">typeobject</span> *<span class="title">tp_next</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; PyTypeObject;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h1 id="Lecture-5-Example-Python-data-types"><a href="#Lecture-5-Example-Python-data-types" class="headerlink" title="Lecture 5. Example Python data types"></a>Lecture 5. Example Python data types</h1><h3 id="1-stringobject"><a href="#1-stringobject" class="headerlink" title="1. stringobject"></a>1. <code>stringobject</code></h3><ul>
<li><p>字符串是不可变类型(immutable)，在python3中，字符串会更复杂一点，因为它要支持各种变长的国际化字符。</p>
</li>
<li><p>每个字符串对象，实际真正只会被创建一次，其他的只是持有其引用，类似于java中的池子。(<a target="_blank" rel="noopener" href="http://wikipedia.org/wiki/String_interning">string interning</a>)，<font color=red> 但是要注意，只有简单的<code>str</code>才会有此feature </font></p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">&quot;hello&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a <span class="keyword">is</span> b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aa = <span class="string">&quot;ashdfijahsdkl jvoi jweoifj asdoik fuiasdhvck jx&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bb = <span class="string">&quot;ashdfijahsdkl jvoi jweoifj asdoik fuiasdhvck jx&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aa <span class="keyword">is</span> bb</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="comment"># 以下这种格式固定的，也会被优化</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aa = <span class="string">&#x27;hellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohello&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bb = <span class="string">&#x27;hellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohellohello&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>aa <span class="keyword">is</span> bb</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>stringobject</code>的定义如下：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Type PyStringObject represents a character string.  An extra zero byte is</span></span><br><span class="line"><span class="comment">reserved at the end to ensure it is zero-terminated, but a size is</span></span><br><span class="line"><span class="comment">present so strings with null bytes in them can be represented.  This</span></span><br><span class="line"><span class="comment">is an immutable object type.</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">There are functions to create new string objects, to test</span></span><br><span class="line"><span class="comment">an object for string-ness, and to get the</span></span><br><span class="line"><span class="comment">string value.  The latter function returns a null pointer</span></span><br><span class="line"><span class="comment">if the object is not of the proper type.</span></span><br><span class="line"><span class="comment">There is a variant that takes an explicit size as well as a</span></span><br><span class="line"><span class="comment">variant that assumes a zero-terminated string.  Note that none of the</span></span><br><span class="line"><span class="comment">functions should be applied to nil objects.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Caching the hash (ob_shash) saves recalculation of a string&#x27;s hash value.</span></span><br><span class="line"><span class="comment">Interning strings (ob_sstate) tries to ensure that only one string</span></span><br><span class="line"><span class="comment">object with a given value exists, so equality tests can be one pointer</span></span><br><span class="line"><span class="comment">comparison.  This is generally restricted to strings that &quot;look like&quot;</span></span><br><span class="line"><span class="comment">Python identifiers, although the intern() builtin can be used to force</span></span><br><span class="line"><span class="comment">interning of any string.</span></span><br><span class="line"><span class="comment">Together, these sped the interpreter by up to 20%. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_VAR_HEAD</span><br><span class="line">    <span class="keyword">long</span> ob_shash;          <span class="comment">// 用于计算字符串的哈希值，会保存在一个驻留字典中，以节约内存（上面注释有说明）</span></span><br><span class="line">    <span class="keyword">int</span> ob_sstate;          <span class="comment">// 如果没有驻留在内存中，就为0</span></span><br><span class="line">    <span class="keyword">char</span> ob_sval[<span class="number">1</span>];        <span class="comment">// 普通的cstring，最后一个字符是0x00</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invariants:</span></span><br><span class="line"><span class="comment">    *     ob_sval contains space for &#x27;ob_size+1&#x27; elements.</span></span><br><span class="line"><span class="comment">    *     ob_sval[ob_size] == 0.</span></span><br><span class="line"><span class="comment">    *     ob_shash is the hash of the string or -1 if not computed yet.</span></span><br><span class="line"><span class="comment">    *     ob_sstate != 0 iff the string object is in stringobject.c&#x27;s</span></span><br><span class="line"><span class="comment">    *       &#x27;interned&#x27; dictionary; in this case the two references</span></span><br><span class="line"><span class="comment">    *       from &#x27;interned&#x27; to this object are *not counted* in ob_refcnt.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125; PyStringObject;</span><br></pre></td></tr></table></figure></li>
<li><p>示例代码</p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py</span></span><br><span class="line">a = <span class="string">&quot;hello&quot;</span></span><br><span class="line">b = <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">a == b</span><br><span class="line">a + b</span><br></pre></td></tr></table></figure>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">PS D:\CODE\Python-2.7.18&gt; python -m dis test.py</span><br><span class="line">1           0 LOAD_CONST               0 (<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">            2 STORE_NAME               0 (a)</span><br><span class="line"></span><br><span class="line">2           4 LOAD_CONST               0 (<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">            6 STORE_NAME               1 (b)</span><br><span class="line"></span><br><span class="line">4           8 LOAD_NAME                0 (a)</span><br><span class="line">            10 LOAD_NAME                1 (b)</span><br><span class="line">            12 COMPARE_OP               2 (==)      <span class="comment"># 比较两个值</span></span><br><span class="line">            14 POP_TOP</span><br><span class="line"></span><br><span class="line">6           16 LOAD_NAME                0 (a)</span><br><span class="line">            18 LOAD_NAME                1 (b)</span><br><span class="line">            20 BINARY_ADD                           <span class="comment"># 字符串连接，只是个普普通通的加法</span></span><br><span class="line">            22 POP_TOP</span><br><span class="line">            24 LOAD_CONST               1 (None)</span><br><span class="line">            26 RETURN_VALUE</span><br></pre></td></tr></table></figure></li>
<li><p>字符串的比较，被执行的就是以上的<code>COMPARE_OP</code>操作码。总体比较的步骤大致如下：</p>
<ul>
<li><code>ceval.c</code>中会对该字节码进行解释执行，从变量栈中取出连个值，由于是字符串，执行到<code>cmp_outcome</code>函数  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// line[2566-2601]</span></span><br><span class="line">TARGET(COMPARE_OP)</span><br><span class="line">&#123;</span><br><span class="line">    w = POP();</span><br><span class="line">    v = TOP();</span><br><span class="line">    <span class="keyword">if</span> (PyInt_CheckExact(w) &amp;&amp; PyInt_CheckExact(v)) &#123;       <span class="comment">// 整形的比较</span></span><br><span class="line">        <span class="comment">/* INLINE: cmp(int, int) */</span></span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">long</span> a, b;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> res;</span><br><span class="line">        a = PyInt_AS_LONG(v);</span><br><span class="line">        b = PyInt_AS_LONG(w);</span><br><span class="line">        <span class="keyword">switch</span> (oparg) &#123;</span><br><span class="line">        <span class="keyword">case</span> PyCmp_LT: res = a &lt;  b; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PyCmp_LE: res = a &lt;= b; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PyCmp_EQ: res = a == b; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PyCmp_NE: res = a != b; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PyCmp_GT: res = a &gt;  b; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PyCmp_GE: res = a &gt;= b; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PyCmp_IS: res = v == w; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PyCmp_IS_NOT: res = v != w; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">goto</span> slow_compare;</span><br><span class="line">        &#125;</span><br><span class="line">        x = res ? Py_True : Py_False;</span><br><span class="line">        Py_INCREF(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        slow_compare:</span><br><span class="line">        x = cmp_outcome(oparg, v, w);                       <span class="comment">// 其他的类型</span></span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(v);</span><br><span class="line">    Py_DECREF(w);</span><br><span class="line">    SET_TOP(x);</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">    PREDICT(POP_JUMP_IF_FALSE);</span><br><span class="line">    PREDICT(POP_JUMP_IF_TRUE);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在<code>cmp_outcome</code>会走到<code>default</code>中的<code>PyObject_RichCompare</code>函数。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">cmp_outcome(<span class="keyword">int</span> op, <span class="keyword">register</span> PyObject *v, <span class="keyword">register</span> PyObject *w)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> PyCmp_IS:                                  <span class="comment">// is的判断 效率会高点</span></span><br><span class="line">        res = (v == w);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PyCmp_IS_NOT:</span><br><span class="line">        res = (v != w);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PyCmp_IN:</span><br><span class="line">        res = PySequence_Contains(w, v);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PyCmp_NOT_IN:</span><br><span class="line">        res = PySequence_Contains(w, v);</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        res = !res;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> PyCmp_EXC_MATCH:</span><br><span class="line">        <span class="comment">// 太长，跳过了，也没看懂，似乎是报警用的</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> PyObject_RichCompare(v, w, op);          <span class="comment">// 走到了这儿</span></span><br><span class="line">    &#125;</span><br><span class="line">    v = res ? Py_True : Py_False;</span><br><span class="line">    Py_INCREF(v);</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在<code>object.c</code>中的<code>PyObject_RichCompare</code>函数中，走到了取比较函数的指针<code>frich</code>并执行的分支，也就是执行了<code>RICHCOMPARE</code>宏定义。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Return:</span></span><br><span class="line"><span class="comment">NULL for exception;</span></span><br><span class="line"><span class="comment">some object not equal to NotImplemented if it is implemented</span></span><br><span class="line"><span class="comment">    (this latter object may not be a Boolean).</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">PyObject *</span><br><span class="line">PyObject_RichCompare(PyObject *v, PyObject *w, <span class="keyword">int</span> op)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *res;</span><br><span class="line"></span><br><span class="line">    assert(Py_LT &lt;= op &amp;&amp; op &lt;= Py_GE);</span><br><span class="line">    <span class="keyword">if</span> (Py_EnterRecursiveCall(<span class="string">&quot; in cmp&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the types are equal, and not old-style instances, try to</span></span><br><span class="line"><span class="comment">    get out cheap (don&#x27;t bother with coercions etc.). */</span></span><br><span class="line">    <span class="keyword">if</span> (v-&gt;ob_type == w-&gt;ob_type &amp;&amp; !PyInstance_Check(v)) &#123;</span><br><span class="line">        cmpfunc fcmp;</span><br><span class="line">        richcmpfunc frich = RICHCOMPARE(v-&gt;ob_type);                <span class="comment">// 这儿会把stringobject中的比较函数指针拿出来</span></span><br><span class="line">        <span class="comment">/* If the type has richcmp, try it first.  try_rich_compare</span></span><br><span class="line"><span class="comment">        tries it two-sided, which is not needed since we&#x27;ve a</span></span><br><span class="line"><span class="comment">        single type only. */</span></span><br><span class="line">        <span class="keyword">if</span> (frich != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            res = (*frich)(v, w, op);                               <span class="comment">// 在这儿执行这个指针所指向的函数</span></span><br><span class="line">            <span class="keyword">if</span> (res != Py_NotImplemented)</span><br><span class="line">                <span class="keyword">goto</span> Done;</span><br><span class="line">            Py_DECREF(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/* No richcmp, or this particular richmp not implemented.</span></span><br><span class="line"><span class="comment">        Try 3-way cmp. */</span></span><br><span class="line">        fcmp = v-&gt;ob_type-&gt;tp_compare;</span><br><span class="line">        <span class="keyword">if</span> (fcmp != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> c = (*fcmp)(v, w);</span><br><span class="line">            c = adjust_tp_compare(c);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="number">-2</span>) &#123;</span><br><span class="line">                res = <span class="literal">NULL</span>;</span><br><span class="line">                <span class="keyword">goto</span> Done;</span><br><span class="line">            &#125;</span><br><span class="line">            res = convert_3way_to_object(op, c);</span><br><span class="line">            <span class="keyword">goto</span> Done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Fast path not taken, or couldn&#x27;t deliver a useful result. */</span></span><br><span class="line">    res = do_richcmp(v, w, op);</span><br><span class="line">Done:</span><br><span class="line">    Py_LeaveRecursiveCall();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>此处，会在运行时拿到<code>stringobject.c</code>里的<code>tp_richcompare</code>，也就是<code>string_richcompare</code>函数，执行，这儿就是最终两个字符串进行比较的地方。  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject*</span><br><span class="line">string_richcompare(PyStringObject *a, PyStringObject *b, <span class="keyword">int</span> op)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    Py_ssize_t len_a, len_b;</span><br><span class="line">    Py_ssize_t min_len;</span><br><span class="line">    PyObject *result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Make sure both arguments are strings. */</span></span><br><span class="line">    <span class="keyword">if</span> (!(PyString_Check(a) &amp;&amp; PyString_Check(b))) &#123;            <span class="comment">// 检查两个参数是否都是字符串类型</span></span><br><span class="line">        result = Py_NotImplemented;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a == b) &#123;                                               <span class="comment">// 判断是否执行同一个PyStringObject</span></span><br><span class="line">        <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">        <span class="keyword">case</span> Py_EQ:<span class="keyword">case</span> Py_LE:<span class="keyword">case</span> Py_GE:</span><br><span class="line">            result = Py_True;                                   <span class="comment">// 此类都为True，否则为False</span></span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        <span class="keyword">case</span> Py_NE:<span class="keyword">case</span> Py_LT:<span class="keyword">case</span> Py_GT:</span><br><span class="line">            result = Py_False;</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (op == Py_EQ) &#123;                                          <span class="comment">// 如果是判断是否相等</span></span><br><span class="line">        <span class="comment">/* Supporting Py_NE here as well does not save</span></span><br><span class="line"><span class="comment">        much time, since Py_NE is rarely used.  */</span></span><br><span class="line">        <span class="keyword">if</span> (Py_SIZE(a) == Py_SIZE(b)                            <span class="comment">// 长度不等的串一定不等</span></span><br><span class="line">            &amp;&amp; (a-&gt;ob_sval[<span class="number">0</span>] == b-&gt;ob_sval[<span class="number">0</span>]                  <span class="comment">// 首字母检查是否相等</span></span><br><span class="line">            &amp;&amp; <span class="built_in">memcmp</span>(a-&gt;ob_sval, b-&gt;ob_sval, Py_SIZE(a)) == <span class="number">0</span>)) &#123;          <span class="comment">// 调用c提供的内存比较方法memcmp</span></span><br><span class="line">            result = Py_True;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result = Py_False;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    len_a = Py_SIZE(a); len_b = Py_SIZE(b);</span><br><span class="line">    min_len = (len_a &lt; len_b) ? len_a : len_b;</span><br><span class="line">    <span class="keyword">if</span> (min_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        c = Py_CHARMASK(*a-&gt;ob_sval) - Py_CHARMASK(*b-&gt;ob_sval);</span><br><span class="line">        <span class="keyword">if</span> (c==<span class="number">0</span>)</span><br><span class="line">            c = <span class="built_in">memcmp</span>(a-&gt;ob_sval, b-&gt;ob_sval, min_len);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        c = (len_a &lt; len_b) ? <span class="number">-1</span> : (len_a &gt; len_b) ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">switch</span> (op) &#123;</span><br><span class="line">    <span class="keyword">case</span> Py_LT: c = c &lt;  <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Py_LE: c = c &lt;= <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Py_EQ: assert(<span class="number">0</span>);  <span class="keyword">break</span>; <span class="comment">/* unreachable */</span></span><br><span class="line">    <span class="keyword">case</span> Py_NE: c = c != <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Py_GT: c = c &gt;  <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> Py_GE: c = c &gt;= <span class="number">0</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        result = Py_NotImplemented;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">    result = c ? Py_True : Py_False;</span><br><span class="line">out:</span><br><span class="line">    Py_INCREF(result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>如何根据<code>tp_richcompare</code>找到对应类型的比较方法呢？我看了下代码，大致流程如下：</p>
<ul>
<li>每种类型都会定义一个<code>PyTypeObeject</code>的类型，例如string就是<code>PyString_Type</code>，每次在创建<code>PyStringObject</code>之后，都会使用该<code>Type</code>对<code>PyObject</code>进行初始化。</li>
<li>在<code>object.c</code>中，先调用<code>PyObject_MALLOC</code>给具体的<code>PyObject</code>分配内存，然后调用<code>PyObject_Init</code>或<code>PyObject_InitVar</code>对其类型进行初始化。本质上执行的就是<code>Py_TYPE</code>，也就是把这个类型赋值给了其中的<code>op_type</code>变量，<code>#define Py_TYPE(ob)              (((PyObject*)(ob))-&gt;ob_type)</code></li>
<li>归根结底，<code>PyObject</code>中的<code>ob_type</code>对应的对象，就已经决定了这个<code>PyObejct</code>的执行轨迹。</li>
</ul>
</li>
<li><p><strong>字符串连接</strong>，本质上是解析并执行了<code>BINARY_ADD</code>这个字节码。执行起来就比较直接了，直接进行类型判断，调用<code>string_concatenate</code>函数</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">TARGET_NOARG(BINARY_ADD)</span><br><span class="line">&#123;</span><br><span class="line">    w = POP();</span><br><span class="line">    v = TOP();</span><br><span class="line">    <span class="keyword">if</span> (PyInt_CheckExact(v) &amp;&amp; PyInt_CheckExact(w)) &#123;</span><br><span class="line">        <span class="comment">/* INLINE: int + int */</span></span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">long</span> a, b, i;</span><br><span class="line">        a = PyInt_AS_LONG(v);</span><br><span class="line">        b = PyInt_AS_LONG(w);</span><br><span class="line">        <span class="comment">/* cast to avoid undefined behaviour</span></span><br><span class="line"><span class="comment">            on overflow */</span></span><br><span class="line">        i = (<span class="keyword">long</span>)((<span class="keyword">unsigned</span> <span class="keyword">long</span>)a + b);</span><br><span class="line">        <span class="keyword">if</span> ((i^a) &lt; <span class="number">0</span> &amp;&amp; (i^b) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">goto</span> slow_add;</span><br><span class="line">        x = PyInt_FromLong(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyString_CheckExact(v) &amp;&amp;                  <span class="comment">// 如果两个变量是字符串类型，就调用连接的函数</span></span><br><span class="line">                PyString_CheckExact(w)) &#123;</span><br><span class="line">        x = string_concatenate(v, w, f, next_instr);</span><br><span class="line">        <span class="comment">/* string_concatenate consumed the ref to v */</span></span><br><span class="line">        <span class="keyword">goto</span> skip_decref_vx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        slow_add:</span><br><span class="line">        x = PyNumber_Add(v, w);</span><br><span class="line">    &#125;</span><br><span class="line">    Py_DECREF(v);</span><br><span class="line">    skip_decref_vx:</span><br><span class="line">    Py_DECREF(w);</span><br><span class="line">    SET_TOP(x);</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">NULL</span>) DISPATCH();</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">string_concat(<span class="keyword">register</span> PyStringObject *a, <span class="keyword">register</span> PyObject *bb)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> Py_ssize_t size;</span><br><span class="line">    <span class="keyword">register</span> PyStringObject *op;</span><br><span class="line">    <span class="keyword">if</span> (!PyString_Check(bb)) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> Py_USING_UNICODE</span></span><br><span class="line">        <span class="keyword">if</span> (PyUnicode_Check(bb))</span><br><span class="line">            <span class="keyword">return</span> PyUnicode_Concat((PyObject *)a, bb);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (PyByteArray_Check(bb))</span><br><span class="line">            <span class="keyword">return</span> PyByteArray_Concat((PyObject *)a, bb);</span><br><span class="line">        PyErr_Format(PyExc_TypeError,</span><br><span class="line">                    <span class="string">&quot;cannot concatenate &#x27;str&#x27; and &#x27;%.200s&#x27; objects&quot;</span>,</span><br><span class="line">                    Py_TYPE(bb)-&gt;tp_name);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> b ((PyStringObject *)bb)</span></span><br><span class="line">    <span class="comment">/* Optimize cases with empty left or right operand */</span></span><br><span class="line">    <span class="keyword">if</span> ((Py_SIZE(a) == <span class="number">0</span> || Py_SIZE(b) == <span class="number">0</span>) &amp;&amp;</span><br><span class="line">        PyString_CheckExact(a) &amp;&amp; PyString_CheckExact(b)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Py_SIZE(a) == <span class="number">0</span>) &#123;</span><br><span class="line">            Py_INCREF(bb);</span><br><span class="line">            <span class="keyword">return</span> bb;</span><br><span class="line">        &#125;</span><br><span class="line">        Py_INCREF(a);</span><br><span class="line">        <span class="keyword">return</span> (PyObject *)a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Check that string sizes are not negative, to prevent an</span></span><br><span class="line"><span class="comment">    overflow in cases where we are passed incorrectly-created</span></span><br><span class="line"><span class="comment">    strings with negative lengths (due to a bug in other code).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span> (Py_SIZE(a) &lt; <span class="number">0</span> || Py_SIZE(b) &lt; <span class="number">0</span> ||</span><br><span class="line">        Py_SIZE(a) &gt; PY_SSIZE_T_MAX - Py_SIZE(b)) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError,</span><br><span class="line">                        <span class="string">&quot;strings are too large to concat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    size = Py_SIZE(a) + Py_SIZE(b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Inline PyObject_NewVar */</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt; PY_SSIZE_T_MAX - PyStringObject_SIZE) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError,</span><br><span class="line">                        <span class="string">&quot;strings are too large to concat&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    op = (PyStringObject *)PyObject_MALLOC(PyStringObject_SIZE + size);</span><br><span class="line">    <span class="keyword">if</span> (op == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> PyErr_NoMemory();</span><br><span class="line">    (<span class="keyword">void</span>)PyObject_INIT_VAR(op, &amp;PyString_Type, size);</span><br><span class="line">    op-&gt;ob_shash = <span class="number">-1</span>;</span><br><span class="line">    op-&gt;ob_sstate = SSTATE_NOT_INTERNED;</span><br><span class="line">    Py_MEMCPY(op-&gt;ob_sval, a-&gt;ob_sval, Py_SIZE(a));                         <span class="comment">// 通过memcpy来拷贝字符串，</span></span><br><span class="line">    Py_MEMCPY(op-&gt;ob_sval + Py_SIZE(a), b-&gt;ob_sval, Py_SIZE(b));</span><br><span class="line">    op-&gt;ob_sval[size] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *) op;                                                 <span class="comment">// 返回一个新的字符串</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h1 id="Lecture-6-Code-objects-function-objects-and-closures"><a href="#Lecture-6-Code-objects-function-objects-and-closures" class="headerlink" title="Lecture 6. Code objects, function objects, and closures"></a>Lecture 6. Code objects, function objects, and closures</h1><h3 id="1-function-object"><a href="#1-function-object" class="headerlink" title="1. function object"></a>1. function object</h3><ul>
<li>在<code>import</code>一个模块的时候，只有当执行到了定义的函数之后，函数名对应的<code>function object</code>才被创建，在这之前是无法获取函数名的，讲函数名赋值给另外一个变量，实质上是创建了一个新的引用指向了该<code>function object</code>。</li>
<li>函数的属性们  <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x, y</span>):</span></span><br><span class="line"><span class="meta">... </span>    z = x + y</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> z</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar = func</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(bar)</span><br><span class="line">[<span class="string">&#x27;__annotations__&#x27;</span>, <span class="string">&#x27;__call__&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__closure__&#x27;</span>, <span class="string">&#x27;__code__&#x27;</span>, <span class="string">&#x27;__defaults__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__get__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__globals__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__kwdefaults__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__name__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__qualname__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bar.__globals__</span><br><span class="line">&#123;&#x27;__name__&#x27;: &#x27;__main__&#x27;, &#x27;__doc__&#x27;: None, &#x27;__package__&#x27;: None, &#x27;__loader__&#x27;: &lt;class &#x27;_frozen_importlib.BuiltinImporter&#x27;&gt;, &#x27;__spec__&#x27;: None, &#x27;__annotations__&#x27;: &#123;&#125;, &#x27;__builtins__&#x27;: &lt;module &#x27;builtins&#x27; (built-in)&gt;, &#x27;func&#x27;: &lt;function func at 0x000001775B29D0D0&gt;, &#x27;bar&#x27;: &lt;function func at 0x000001775B29D0D0&gt;&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>__globals__</code>（在python2中是<code>func_globals</code>）是函数对象的一个成员变量，为什么有这个变量，因为对于函数而言，它的全局变量是以文件为单位的，不同py文件中的函数，他们的<code>__globals__</code>是不一样的。因此对于两段完全相同的代码（<code>__code__</code>），可以因为环境的不同，产生完全不同的结果。</li>
<li>python中的<code>code object</code>拥有的属性如下，<code>co_code</code>就是经过编译之后的字节码  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>func.__code__.co_code</span><br><span class="line"><span class="string">b&#x27;|\x00|\x01\x17\x00&#125;\x02|\x02S\x00&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(func.__code__)</span><br><span class="line">[<span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;co_argcount&#x27;</span>, <span class="string">&#x27;co_cellvars&#x27;</span>, <span class="string">&#x27;co_code&#x27;</span>, <span class="string">&#x27;co_consts&#x27;</span>, <span class="string">&#x27;co_filename&#x27;</span>, <span class="string">&#x27;co_firstlineno&#x27;</span>, <span class="string">&#x27;co_flags&#x27;</span>, <span class="string">&#x27;co_freevars&#x27;</span>, <span class="string">&#x27;co_kwonlyargcount&#x27;</span>, <span class="string">&#x27;co_lnotab&#x27;</span>, <span class="string">&#x27;co_name&#x27;</span>, <span class="string">&#x27;co_names&#x27;</span>, <span class="string">&#x27;co_nlocals&#x27;</span>, <span class="string">&#x27;co_posonlyargcount&#x27;</span>, <span class="string">&#x27;co_stacksize&#x27;</span>, <span class="string">&#x27;co_varnames&#x27;</span>, <span class="string">&#x27;replace&#x27;</span>]</span><br></pre></td></tr></table></figure></li>
<li><code>bytecode object</code>的cpython源码，在<code>code.h</code>中定义的<code>PyCodeObject</code>。第三讲里的笔记已经贴了源码了。</li>
</ul>
<h3 id="2-funcobject"><a href="#2-funcobject" class="headerlink" title="2. funcobject"></a>2. <code>funcobject</code></h3><ul>
<li><p>cpython源码中的<code>PyFUnctionObejct</code>(在<code>funcobject.h</code>中的定义)</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    PyObject *func_code;	<span class="comment">/* A code object */</span>                             <span class="comment">// code object 里面存的编译后的字节码</span></span><br><span class="line">    PyObject *func_globals;	<span class="comment">/* A dictionary (other mappings won&#x27;t do) */</span>        <span class="comment">// 全局变量</span></span><br><span class="line">    PyObject *func_defaults;	<span class="comment">/* NULL or a tuple */</span></span><br><span class="line">    PyObject *func_closure;	<span class="comment">/* NULL or a tuple of cell objects */</span>               <span class="comment">// 里面存的是闭包里的变量</span></span><br><span class="line">    PyObject *func_doc;		<span class="comment">/* The __doc__ attribute, can be anything */</span></span><br><span class="line">    PyObject *func_name;	<span class="comment">/* The __name__ attribute, a string object */</span></span><br><span class="line">    PyObject *func_dict;	<span class="comment">/* The __dict__ attribute, a dict or NULL */</span></span><br><span class="line">    PyObject *func_weakreflist;	<span class="comment">/* List of weak references */</span></span><br><span class="line">    PyObject *func_module;	<span class="comment">/* The __module__ attribute, can be anything */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Invariant:           </span></span><br><span class="line"><span class="comment">    // 这儿对闭包的变量解释了以下co_freevars里存的就是函数作用域范围外的变量，co_freevars和closure里的cell应是一一对应的</span></span><br><span class="line"><span class="comment">    *     func_closure contains the bindings for func_code-&gt;co_freevars, so</span></span><br><span class="line"><span class="comment">    *     PyTuple_Size(func_closure) == PyCode_GetNumFree(func_code)</span></span><br><span class="line"><span class="comment">    *     (func_closure may be NULL if PyCode_GetNumFree(func_code) == 0).</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125; PyFunctionObject;</span><br></pre></td></tr></table></figure></li>
<li><p>在<code>funcobejct.c</code>中，构造一个<code>PyfunctionObejct</code>只需需要传入两个参数，<code>code object</code>和<code>globals</code>，分别指的是函数的字节码和全局变量的指针。它的函数声明如下，<code>PyObject * PyFunction_New(PyObject *code, PyObject *globals)</code></p>
</li>
<li><p><code>PyMemberDef</code>和<code>PyGetSetDef</code>，里面定义的是从python控制台里可以直接取到的变量。，对于<code>PyGetSetDef</code>里，还定义了一些可以修改的变量。</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyMemberDef func_memberlist[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;func_closure&quot;</span>,  T_OBJECT,     OFF(func_closure),</span><br><span class="line">    RESTRICTED|READONLY&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;__closure__&quot;</span>,  T_OBJECT,      OFF(func_closure),</span><br><span class="line">    RESTRICTED|READONLY&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;func_doc&quot;</span>,      T_OBJECT,     OFF(func_doc), PY_WRITE_RESTRICTED&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;__doc__&quot;</span>,       T_OBJECT,     OFF(func_doc), PY_WRITE_RESTRICTED&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;func_globals&quot;</span>,  T_OBJECT,     OFF(func_globals),</span><br><span class="line">    RESTRICTED|READONLY&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;__globals__&quot;</span>,  T_OBJECT,      OFF(func_globals),</span><br><span class="line">    RESTRICTED|READONLY&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;__module__&quot;</span>,    T_OBJECT,     OFF(func_module), PY_WRITE_RESTRICTED&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>&#125;  <span class="comment">/* Sentinel */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyGetSetDef func_getsetlist[] = &#123;</span><br><span class="line">    &#123;<span class="string">&quot;func_code&quot;</span>, (getter)func_get_code, (setter)func_set_code&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;__code__&quot;</span>, (getter)func_get_code, (setter)func_set_code&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;func_defaults&quot;</span>, (getter)func_get_defaults,</span><br><span class="line">    (setter)func_set_defaults&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;__defaults__&quot;</span>, (getter)func_get_defaults,</span><br><span class="line">    (setter)func_set_defaults&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;func_dict&quot;</span>, (getter)func_get_dict, (setter)func_set_dict&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;__dict__&quot;</span>, (getter)func_get_dict, (setter)func_set_dict&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;func_name&quot;</span>, (getter)func_get_name, (setter)func_set_name&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;__name__&quot;</span>, (getter)func_get_name, (setter)func_set_name&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>&#125; <span class="comment">/* Sentinel */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>对于一个<code>function object</code>而言，其核心的功能，调用函数功能由函数<code>function_call</code>函数完成，它定义在了<code>PyFunction_Type</code>中(也就是<code>PyObject</code>里函数对象所对应的类型)，通过<code>tp_call</code>属性即可引用到它。</p>
</li>
<li><p><code>function_call</code>实现功能的方式是取出<code>PyFunction</code>中的<code>PyCodeObject</code>、<code>globals</code>等，交由<code>ceval.c</code>中的<code>PyEval_EvalCodeEx</code>执行，然后构造出一个<code>PyFrameObejct</code>，交由<code>PyEval_EvalFrameEx</code>完成对字节码的解析并执行的结果。（又回到最初的起点）</p>
</li>
</ul>
<h3 id="3-closures（闭包）"><a href="#3-closures（闭包）" class="headerlink" title="3. closures（闭包）"></a>3. <code>closures</code>（闭包）</h3><ul>
<li>示例代码  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">x</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span>(<span class="params">y</span>):</span></span><br><span class="line">        print(x + y)</span><br><span class="line">    <span class="keyword">return</span> bar</span><br><span class="line"></span><br><span class="line">b1 = foo(<span class="number">10</span>)</span><br><span class="line">b1(<span class="number">1</span>)</span><br><span class="line">b2 = foo(<span class="number">20</span>)</span><br><span class="line">b2(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li>
<li>对于以上代码，<code>b1</code>是一个<code>function object</code>，它是一个闭包，拥有一个指向运行<code>foo(10)</code>时创建的<code>frame object</code>的指针，同时，该<code>frame object</code>由于拥有一个引用，也不会销毁，所以写代码时容易产生循环引用问题。</li>
<li>上面说的并不对，python并不会持有整个<code>frame object</code>，而是只保留了那唯一的一个变量<code>10</code>和<code>20</code>，它保存在了函数的<code>func_closure</code>中（python3中是<code>__closure__</code>属性），里面是一个<code>cell</code>类型的元组，其中<code>cell.cell_contents</code>里存储的就是上述的变量。  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> test</span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test.b1.__closure__</span><br><span class="line">(&lt;cell at <span class="number">0x000001E9BEFD5BB0</span>: int object at <span class="number">0x00007FFD788D17C0</span>&gt;,)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line"><span class="comment"># 数值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test.b1.__closure__[<span class="number">0</span>].cell_contents</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="comment"># 变量名与__closure__中的cell个数是一一对应的（在上面的注释里有说）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test.b1.__code__.co_freevars</span><br><span class="line">(<span class="string">&#x27;x&#x27;</span>,)</span><br></pre></td></tr></table></figure></li>
<li>闭包执行的字节码如下  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dis.dis(test.b1)</span><br><span class="line"><span class="number">5</span>           <span class="number">0</span> LOAD_GLOBAL              <span class="number">0</span> (<span class="keyword">print</span>)</span><br><span class="line">            <span class="number">2</span> LOAD_DEREF               <span class="number">0</span> (x)                <span class="comment"># 这儿就是读取闭包中变量的字节码</span></span><br><span class="line">            <span class="number">4</span> LOAD_FAST                <span class="number">0</span> (y)</span><br><span class="line">            <span class="number">6</span> BINARY_ADD</span><br><span class="line">            <span class="number">8</span> CALL_FUNCTION            <span class="number">1</span></span><br><span class="line">            <span class="number">10</span> POP_TOP</span><br><span class="line">            <span class="number">12</span> LOAD_CONST               <span class="number">0</span> (<span class="literal">None</span>)</span><br><span class="line">            <span class="number">14</span> RETURN_VALUE</span><br></pre></td></tr></table></figure>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">TARGET(LOAD_DEREF)</span><br><span class="line">&#123;</span><br><span class="line">    x = freevars[oparg];            <span class="comment">// 可以看到变量名是存在了freevars里，也就是上面的`test.b1.__code__.co_freevars`</span></span><br><span class="line">    w = PyCell_Get(x);</span><br><span class="line">    <span class="keyword">if</span> (w != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        PUSH(w);</span><br><span class="line">        DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    err = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">/* Don&#x27;t stomp existing exception */</span></span><br><span class="line">    <span class="keyword">if</span> (PyErr_Occurred())</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span> (oparg &lt; PyTuple_GET_SIZE(co-&gt;co_cellvars)) &#123;</span><br><span class="line">        v = PyTuple_GET_ITEM(co-&gt;co_cellvars,</span><br><span class="line">                                oparg);</span><br><span class="line">        format_exc_check_arg(</span><br><span class="line">                PyExc_UnboundLocalError,</span><br><span class="line">                UNBOUNDLOCAL_ERROR_MSG,</span><br><span class="line">                v);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        v = PyTuple_GET_ITEM(co-&gt;co_freevars, oparg -</span><br><span class="line">            PyTuple_GET_SIZE(co-&gt;co_cellvars));</span><br><span class="line">        format_exc_check_arg(PyExc_NameError,</span><br><span class="line">                                UNBOUNDFREE_ERROR_MSG, v);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h1 id="Lecture-7-Iterators"><a href="#Lecture-7-Iterators" class="headerlink" title="Lecture 7. Iterators"></a>Lecture 7. Iterators</h1><h3 id="1-迭代器"><a href="#1-迭代器" class="headerlink" title="1. 迭代器"></a>1. 迭代器</h3><ul>
<li><p>像<code>list</code>之类的是可迭代对象，<code>__iter__()</code>方法会返回一个迭代器，通过<code>next()</code>函数可以不断取出迭代器中元素，直至抛出<code>StopIteration</code>异常，在<a target="_blank" rel="noopener" href="https://wz2671.github.io/2020/12/13/%E6%B5%81%E7%95%85%E7%9A%84python/">流畅的python中十四章</a>有更详细说明。</p>
</li>
<li><p>测试代码<code>test.py</code></p>
  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> e <span class="keyword">in</span> x:</span><br><span class="line">    <span class="keyword">print</span> e</span><br></pre></td></tr></table></figure></li>
<li><p>python编译之后，这儿是python3编译后的结果，和python2的差别挺大，python2还有个<code>SETUP_LOOP</code>的字节码</p>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">PS D:\CODE\Python-2.7.18&gt; python -m dis .\test.py</span><br><span class="line">1           0 LOAD_CONST               0 (<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">            2 LOAD_CONST               1 (<span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">            4 LOAD_CONST               2 (<span class="string">&#x27;c&#x27;</span>)</span><br><span class="line">            6 BUILD_LIST               3</span><br><span class="line">            8 STORE_NAME               0 (x)</span><br><span class="line"></span><br><span class="line">2          10 LOAD_NAME                0 (x)</span><br><span class="line">           12 GET_ITER</span><br><span class="line">      &gt;&gt;   14 FOR_ITER                12 (to 28)        <span class="comment"># 在14-28之前都是循环里的代码，stop之后，会跳到28</span></span><br><span class="line">           16 STORE_NAME               1 (e)</span><br><span class="line"></span><br><span class="line">3          18 LOAD_NAME                2 (<span class="built_in">print</span>)</span><br><span class="line">           20 LOAD_NAME                1 (e)</span><br><span class="line">           22 CALL_FUNCTION            1</span><br><span class="line">           24 POP_TOP</span><br><span class="line">           26 JUMP_ABSOLUTE           14</span><br><span class="line">      &gt;&gt;   28 LOAD_CONST               3 (None)</span><br><span class="line">           30 RETURN_VALUE</span><br></pre></td></tr></table></figure></li>
<li><p>因此<code>for</code>循环的核心代码，主要是<code>GET_ITER</code>和<code>FOR_ITER</code>操作码，他们的cpython源码实现如下：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">TARGET_NOARG(GET_ITER)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* before: [obj]; after [getiter(obj)] */</span></span><br><span class="line">    v = TOP();</span><br><span class="line">    x = PyObject_GetIter(v);            <span class="comment">// 获取v的迭代器</span></span><br><span class="line">    Py_DECREF(v);</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        SET_TOP(x);                     <span class="comment">// 迭代器放到了栈顶</span></span><br><span class="line">        PREDICT(FOR_ITER);              <span class="comment">// 预测并直接跳到下一个操作码FOR_ITER</span></span><br><span class="line">        DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    STACKADJ(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PREDICTED_WITH_ARG(FOR_ITER);           <span class="comment">// 从这儿执行，只是一重eval循环</span></span><br><span class="line">TARGET(FOR_ITER)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* before: [iter]; after: [iter, iter()] *or* [] */</span></span><br><span class="line">    v = TOP();                          <span class="comment">// 此时这儿是那个迭代器</span></span><br><span class="line">    x = (*v-&gt;ob_type-&gt;tp_iternext)(v);  <span class="comment">// 取出了迭代器的next方法，并调用，这儿返回的就是具体的变量</span></span><br><span class="line">    <span class="keyword">if</span> (x != <span class="literal">NULL</span>) &#123;                    <span class="comment">// 根据next函数返回的结果判断是否结束for循环</span></span><br><span class="line">        PUSH(x);                        <span class="comment">// 压入变量栈中</span></span><br><span class="line">        PREDICT(STORE_FAST);            <span class="comment">// 存到了for循环里那个局部变量中</span></span><br><span class="line">        PREDICT(UNPACK_SEQUENCE);</span><br><span class="line">        DISPATCH();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (PyErr_Occurred()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!PyErr_ExceptionMatches(</span><br><span class="line">                        PyExc_StopIteration))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        PyErr_Clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* iterator ended normally */</span></span><br><span class="line">    x = v = POP();</span><br><span class="line">    Py_DECREF(v);</span><br><span class="line">    JUMPBY(oparg);</span><br><span class="line">    DISPATCH();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>获取迭代器的方法<code>PyObject_GetIter</code>定义在了<code>abstarct.h</code>中，是一个抽象基础方法。具体实现是尝试获取PyObject的<code>tp_iter</code>方法，如果没有找到的话，会尝试构建一个迭代器，实现代码如下：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyObject_GetIter(PyObject *o)</span><br><span class="line">&#123;</span><br><span class="line">    PyTypeObject *t = o-&gt;ob_type;</span><br><span class="line">    getiterfunc f = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (PyType_HasFeature(t, Py_TPFLAGS_HAVE_ITER))     <span class="comment">// 会根据类型定义标志的作比较</span></span><br><span class="line">        f = t-&gt;tp_iter;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PySequence_Check(o))</span><br><span class="line">            <span class="keyword">return</span> PySeqIter_New(o);                    <span class="comment">// 对于list而言，会走这儿构建一个新的迭代器</span></span><br><span class="line">        <span class="keyword">return</span> type_error(<span class="string">&quot;&#x27;%.200s&#x27; object is not iterable&quot;</span>, o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        PyObject *res = (*f)(o);</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="literal">NULL</span> &amp;&amp; !PyIter_Check(res)) &#123;</span><br><span class="line">            PyErr_Format(PyExc_TypeError,</span><br><span class="line">                        <span class="string">&quot;iter() returned non-iterator &quot;</span></span><br><span class="line">                        <span class="string">&quot;of type &#x27;%.100s&#x27;&quot;</span>,</span><br><span class="line">                        res-&gt;ob_type-&gt;tp_name);</span><br><span class="line">            Py_DECREF(res);</span><br><span class="line">            res = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造迭代器的方法<code>PySeqIter_New</code>定义在了<code>iterobejct.c</code>，第一个接口就是，主要思路就创建一个迭代器对象，把索引和对象的指针设置一下完毕，迭代器的定义如下：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="keyword">long</span>      it_index;</span><br><span class="line">    PyObject *it_seq; <span class="comment">/* Set to NULL when iterator is exhausted */</span></span><br><span class="line">&#125; seqiterobject;</span><br></pre></td></tr></table></figure></li>
<li><p>对于调用<code>next</code>方法，也就是<code>ceval.c</code>中的<code>x = (*v-&gt;ob_type-&gt;tp_iternext)(v)</code>语句，对于上述例子，会执行<code>iter_iternext</code>方法，实现的源码如下：</p>
  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">iter_iternext(PyObject *iterator)</span><br><span class="line">&#123;</span><br><span class="line">    seqiterobject *it;</span><br><span class="line">    PyObject *seq;</span><br><span class="line">    PyObject *result;</span><br><span class="line"></span><br><span class="line">    assert(PySeqIter_Check(iterator));      <span class="comment">// 检查是否是一个迭代器</span></span><br><span class="line">    it = (seqiterobject *)iterator;</span><br><span class="line">    seq = it-&gt;it_seq;                       <span class="comment">// 取出其中的序列</span></span><br><span class="line">    <span class="keyword">if</span> (seq == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (it-&gt;it_index == LONG_MAX) &#123;</span><br><span class="line">        PyErr_SetString(PyExc_OverflowError,</span><br><span class="line">                        <span class="string">&quot;iter index too large&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    result = PySequence_GetItem(seq, it-&gt;it_index);         <span class="comment">// 类似于直接按下标取值seq[it-&gt;it_index]</span></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        it-&gt;it_index++;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (PyErr_ExceptionMatches(PyExc_IndexError) ||             <span class="comment">// StopIteration或索引越界都认为结束了</span></span><br><span class="line">        PyErr_ExceptionMatches(PyExc_StopIteration))</span><br><span class="line">    &#123;</span><br><span class="line">        PyErr_Clear();</span><br><span class="line">        it-&gt;it_seq = <span class="literal">NULL</span>;                  <span class="comment">// 将序列的指针置为null</span></span><br><span class="line">        Py_DECREF(seq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;                            <span class="comment">// 返回，后续会根据null决定是否结束for循环</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h1 id="Lecture-8-User-defined-classes-and-objects"><a href="#Lecture-8-User-defined-classes-and-objects" class="headerlink" title="Lecture 8. User-defined classes and objects"></a>Lecture 8. User-defined classes and objects</h1><h3 id="1-class"><a href="#1-class" class="headerlink" title="1. class"></a>1. class</h3><ul>
<li>python测试代码(test.py)  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span>(<span class="params">object</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, low, high</span>):</span></span><br><span class="line">        self.current = low</span><br><span class="line">        self.high = high</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span>         <span class="comment"># 在python2中，没有双下划线，就叫`next`</span></span><br><span class="line">        <span class="keyword">if</span> self.current &gt; self.high:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.current += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> self.current - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">c =  Counter(<span class="number">5</span>, <span class="number">7</span>)</span><br></pre></td></tr></table></figure>
  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">PS D:\CODE\Python-2.7.18&gt; python -m dis .\test.py</span><br><span class="line"><span class="comment"># 这部分就是定义类class Counter和创建Counter对象c的部分，使用python2编译器编译出来的内容只会打印这部分</span></span><br><span class="line">1            0 LOAD_BUILD_CLASS        <span class="comment"># python2中，是先load多个const，才执行BUILD_CLASS</span></span><br><span class="line">             2 LOAD_CONST               0 (&lt;code object Counter at 0x000001C5B0ACAEA0, file <span class="string">&quot;.\test.py&quot;</span>, line 1&gt;)</span><br><span class="line">             4 LOAD_CONST               1 (<span class="string">&#x27;Counter&#x27;</span>)</span><br><span class="line">             6 MAKE_FUNCTION            0</span><br><span class="line">             8 LOAD_CONST               1 (<span class="string">&#x27;Counter&#x27;</span>)</span><br><span class="line">            10 LOAD_NAME                0 (object)</span><br><span class="line">            12 CALL_FUNCTION            3</span><br><span class="line">            14 STORE_NAME               1 (Counter)</span><br><span class="line"></span><br><span class="line">16          16 LOAD_NAME                1 (Counter)</span><br><span class="line">            18 LOAD_CONST               2 (5)</span><br><span class="line">            20 LOAD_CONST               3 (7)</span><br><span class="line">            22 CALL_FUNCTION            2</span><br><span class="line">            24 STORE_NAME               2 (c)</span><br><span class="line">            26 LOAD_CONST               4 (None)</span><br><span class="line">            28 RETURN_VALUE</span><br><span class="line"><span class="comment"># 这儿是创建类 本身这个对象的部分，主要就是定义了它的各个函数的code object</span></span><br><span class="line">Disassembly of &lt;code object Counter at 0x000001992E279EA0, file <span class="string">&quot;.\test.py&quot;</span>, line 1&gt;:</span><br><span class="line">1            0 LOAD_NAME                0 (__name__)</span><br><span class="line">             2 STORE_NAME               1 (__module__)</span><br><span class="line">             4 LOAD_CONST               0 (<span class="string">&#x27;Counter&#x27;</span>)</span><br><span class="line">             6 STORE_NAME               2 (__qualname__)</span><br><span class="line"></span><br><span class="line">2            8 LOAD_CONST               1 (&lt;code object __init__ at 0x000001992E279C90, file <span class="string">&quot;.\test.py&quot;</span>, line 2&gt;)</span><br><span class="line">            10 LOAD_CONST               2 (<span class="string">&#x27;Counter.__init__&#x27;</span>)</span><br><span class="line">            12 MAKE_FUNCTION            0</span><br><span class="line">            14 STORE_NAME               3 (__init__)</span><br><span class="line"></span><br><span class="line">6           16 LOAD_CONST               3 (&lt;code object __iter__ at 0x000001992E279D40, file <span class="string">&quot;.\test.py&quot;</span>, line 6&gt;)</span><br><span class="line">            18 LOAD_CONST               4 (<span class="string">&#x27;Counter.__iter__&#x27;</span>)</span><br><span class="line">            20 MAKE_FUNCTION            0</span><br><span class="line">            22 STORE_NAME               4 (__iter__)</span><br><span class="line"></span><br><span class="line">9           24 LOAD_CONST               5 (&lt;code object next at 0x000001992E279DF0, file <span class="string">&quot;.\test.py&quot;</span>, line 9&gt;)</span><br><span class="line">            26 LOAD_CONST               6 (<span class="string">&#x27;Counter.next&#x27;</span>)</span><br><span class="line">            28 MAKE_FUNCTION            0</span><br><span class="line">            30 STORE_NAME               5 (next)</span><br><span class="line">            32 LOAD_CONST               7 (None)</span><br><span class="line">            34 RETURN_VALUE</span><br><span class="line"><span class="comment"># 这儿是__init__函数的部分</span></span><br><span class="line">Disassembly of &lt;code object __init__ at 0x000001992E279C90, file <span class="string">&quot;.\test.py&quot;</span>, line 2&gt;:</span><br><span class="line">3            0 LOAD_FAST                1 (low)</span><br><span class="line">             2 LOAD_FAST                0 (self)</span><br><span class="line">             4 STORE_ATTR               0 (current)</span><br><span class="line"></span><br><span class="line">4            6 LOAD_FAST                2 (high)</span><br><span class="line">             8 LOAD_FAST                0 (self)</span><br><span class="line">            10 STORE_ATTR               1 (high)</span><br><span class="line">            12 LOAD_CONST               0 (None)</span><br><span class="line">            14 RETURN_VALUE</span><br><span class="line"><span class="comment"># __iter__部分</span></span><br><span class="line">Disassembly of &lt;code object __iter__ at 0x000001992E279D40, file <span class="string">&quot;.\test.py&quot;</span>, line 6&gt;:</span><br><span class="line">7           0 LOAD_FAST                0 (self)</span><br><span class="line">            2 RETURN_VALUE</span><br><span class="line"><span class="comment"># next函数</span></span><br><span class="line">Disassembly of &lt;code object __next__ at 0x000001992E279DF0, file <span class="string">&quot;.\test.py&quot;</span>, line 9&gt;:</span><br><span class="line">10           0 LOAD_FAST                0 (self)</span><br><span class="line">             2 LOAD_ATTR                0 (current)</span><br><span class="line">             4 LOAD_FAST                0 (self)</span><br><span class="line">             6 LOAD_ATTR                1 (high)</span><br><span class="line">             8 COMPARE_OP               4 (&gt;)</span><br><span class="line">            10 POP_JUMP_IF_FALSE       18</span><br><span class="line"></span><br><span class="line">11          12 LOAD_GLOBAL              2 (StopIteration)</span><br><span class="line">            14 RAISE_VARARGS            1</span><br><span class="line">            16 JUMP_FORWARD            24 (to 42)</span><br><span class="line"></span><br><span class="line">13     &gt;&gt;   18 LOAD_FAST                0 (self)</span><br><span class="line">            20 DUP_TOP</span><br><span class="line">            22 LOAD_ATTR                0 (current)</span><br><span class="line">            24 LOAD_CONST               1 (1)</span><br><span class="line">            26 INPLACE_ADD</span><br><span class="line">            28 ROT_TWO</span><br><span class="line">            30 STORE_ATTR               0 (current)</span><br><span class="line"></span><br><span class="line">14          32 LOAD_FAST                0 (self)</span><br><span class="line">            34 LOAD_ATTR                0 (current)</span><br><span class="line">            36 LOAD_CONST               1 (1)</span><br><span class="line">            38 BINARY_SUBTRACT</span><br><span class="line">            40 RETURN_VALUE</span><br><span class="line">        &gt;&gt;  42 LOAD_CONST               0 (None)</span><br><span class="line">            44 RETURN_VALUE</span><br></pre></td></tr></table></figure></li>
<li>由于python版本问题，上面的编译结果和展示的代码并不一致（问题不大</li>
<li><code>BUILD_CLASS</code>字节码在<code>ceval.c</code>中的代码如下：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">TARGET_NOARG(BUILD_CLASS)</span><br><span class="line">&#123;</span><br><span class="line">    u = TOP();      <span class="comment">// 函数的字典</span></span><br><span class="line">    v = SECOND();   <span class="comment">// 基类</span></span><br><span class="line">    w = THIRD();    <span class="comment">// 类名</span></span><br><span class="line">    STACKADJ(<span class="number">-2</span>);</span><br><span class="line">    x = build_class(u, v, w);</span><br><span class="line">    SET_TOP(x);</span><br><span class="line">    Py_DECREF(u);</span><br><span class="line">    Py_DECREF(v);</span><br><span class="line">    Py_DECREF(w);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">build_class(PyObject *methods, PyObject *bases, PyObject *name)</span><br><span class="line">&#123;</span><br><span class="line">    PyObject *metaclass = <span class="literal">NULL</span>, *result, *base;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (PyDict_Check(methods))      <span class="comment">// 对函数做检查</span></span><br><span class="line">        metaclass = PyDict_GetItemString(methods, <span class="string">&quot;__metaclass__&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (metaclass != <span class="literal">NULL</span>)</span><br><span class="line">        Py_INCREF(metaclass);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (PyTuple_Check(bases) &amp;&amp; PyTuple_GET_SIZE(bases) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        base = PyTuple_GET_ITEM(bases, <span class="number">0</span>);</span><br><span class="line">        metaclass = PyObject_GetAttrString(base, <span class="string">&quot;__class__&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (metaclass == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            PyErr_Clear();</span><br><span class="line">            metaclass = (PyObject *)base-&gt;ob_type;</span><br><span class="line">            Py_INCREF(metaclass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        PyObject *g = PyEval_GetGlobals();</span><br><span class="line">        <span class="keyword">if</span> (g != <span class="literal">NULL</span> &amp;&amp; PyDict_Check(g))</span><br><span class="line">            metaclass = PyDict_GetItemString(g, <span class="string">&quot;__metaclass__&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (metaclass == <span class="literal">NULL</span>)</span><br><span class="line">            metaclass = (PyObject *) &amp;PyClass_Type;</span><br><span class="line">        Py_INCREF(metaclass);</span><br><span class="line">    &#125;</span><br><span class="line">    result = PyObject_CallFunctionObjArgs(metaclass, name, bases, methods,</span><br><span class="line">                                        <span class="literal">NULL</span>);  <span class="comment">// 函数内部调用了metaclass-&gt;ob_type-&gt;tp_call执行了`PyClass_New`</span></span><br><span class="line">    Py_DECREF(metaclass);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="literal">NULL</span> &amp;&amp; PyErr_ExceptionMatches(PyExc_TypeError)) &#123;</span><br><span class="line">        <span class="comment">/* A type error here likely means that the user passed</span></span><br><span class="line"><span class="comment">        in a base that was not a class (such the random module</span></span><br><span class="line"><span class="comment">        instead of the random.random type).  Help them out with</span></span><br><span class="line"><span class="comment">        by augmenting the error message with more information.*/</span></span><br><span class="line"></span><br><span class="line">        PyObject *ptype, *pvalue, *ptraceback;</span><br><span class="line"></span><br><span class="line">        PyErr_Fetch(&amp;ptype, &amp;pvalue, &amp;ptraceback);</span><br><span class="line">        <span class="keyword">if</span> (PyString_Check(pvalue)) &#123;</span><br><span class="line">            PyObject *newmsg;</span><br><span class="line">            newmsg = PyString_FromFormat(</span><br><span class="line">                <span class="string">&quot;Error when calling the metaclass bases\n&quot;</span></span><br><span class="line">                <span class="string">&quot;    %s&quot;</span>,</span><br><span class="line">                PyString_AS_STRING(pvalue));</span><br><span class="line">            <span class="keyword">if</span> (newmsg != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                Py_DECREF(pvalue);</span><br><span class="line">                pvalue = newmsg;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        PyErr_Restore(ptype, pvalue, ptraceback);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure></li>
<li><code>classobject</code>里定义的类对象，类实例对象，类方法对象  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    PyObject	*cl_bases;	<span class="comment">/* A tuple of class objects */</span>      <span class="comment">// 基类</span></span><br><span class="line">    PyObject	*cl_dict;	<span class="comment">/* A dictionary */</span>                  <span class="comment">// 方法字典</span></span><br><span class="line">    PyObject	*cl_name;	<span class="comment">/* A string */</span>                      <span class="comment">// 类型</span></span><br><span class="line">    <span class="comment">/* The following three are functions or NULL */</span>         <span class="comment">// 应该是属性描述符（流畅的python中有介绍）</span></span><br><span class="line">    PyObject	*cl_getattr;</span><br><span class="line">    PyObject	*cl_setattr;</span><br><span class="line">    PyObject	*cl_delattr;</span><br><span class="line">    PyObject    *cl_weakreflist; <span class="comment">/* List of weak references */</span></span><br><span class="line">&#125; PyClassObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    PyClassObject *in_class;	<span class="comment">/* The class object */</span>          <span class="comment">// 所属的类</span></span><br><span class="line">    PyObject	  *in_dict;	<span class="comment">/* A dictionary */</span>                  <span class="comment">// 实例对象里的字典也就是__dict__</span></span><br><span class="line">    PyObject	  *in_weakreflist; <span class="comment">/* List of weak references */</span></span><br><span class="line">&#125; PyInstanceObject;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    PyObject *im_func;   <span class="comment">/* The callable object implementing the method */</span>      <span class="comment">// 原始函数本身</span></span><br><span class="line">    PyObject *im_self;   <span class="comment">/* The instance it is bound to, or NULL */</span>         <span class="comment">// 指向实例对象自己的指针（我懂得）</span></span><br><span class="line">    PyObject *im_class;  <span class="comment">/* The class that asked for the method */</span>          <span class="comment">// 所属的类</span></span><br><span class="line">    PyObject *im_weakreflist; <span class="comment">/* List of weak references */</span></span><br><span class="line">&#125; PyMethodObject;</span><br></pre></td></tr></table></figure></li>
<li>使用python定义的类实例化对象，通过执行<code>CALL_FUNCTION</code>字节码，最终调用了<code>PyInstance_New</code>函数(<code>PyClass_Type-&gt;tp_call</code>指针所指向的方法)  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">PyObject *</span><br><span class="line">PyInstance_New(PyObject *klass, PyObject *arg, PyObject *kw)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> PyInstanceObject *inst;</span><br><span class="line">    PyObject *init;</span><br><span class="line">    <span class="keyword">static</span> PyObject *initstr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (initstr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        initstr = PyString_InternFromString(<span class="string">&quot;__init__&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (initstr == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inst = (PyInstanceObject *) PyInstance_NewRaw(klass, <span class="literal">NULL</span>);     <span class="comment">// 这儿是创建实例对象的</span></span><br><span class="line">    <span class="keyword">if</span> (inst == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    init = instance_getattr2(inst, initstr);                        <span class="comment">// 获取__init__方法</span></span><br><span class="line">    <span class="keyword">if</span> (init == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (PyErr_Occurred()) &#123;</span><br><span class="line">            Py_DECREF(inst);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((arg != <span class="literal">NULL</span> &amp;&amp; (!PyTuple_Check(arg) ||</span><br><span class="line">                            PyTuple_Size(arg) != <span class="number">0</span>))</span><br><span class="line">            || (kw != <span class="literal">NULL</span> &amp;&amp; (!PyDict_Check(kw) ||</span><br><span class="line">                            PyDict_Size(kw) != <span class="number">0</span>))) &#123;</span><br><span class="line">            PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                    <span class="string">&quot;this constructor takes no arguments&quot;</span>);</span><br><span class="line">            Py_DECREF(inst);</span><br><span class="line">            inst = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        PyObject *res = PyEval_CallObjectWithKeywords(init, arg, kw); <span class="comment">// 执行init方法，注意这儿的method方法有instance对象本身(im_self)，因此不需要再额外传入实例化的对象inst</span></span><br><span class="line">        Py_DECREF(init);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Py_DECREF(inst);</span><br><span class="line">            inst = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (res != Py_None) &#123;</span><br><span class="line">                PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                        <span class="string">&quot;__init__() should return None&quot;</span>);</span><br><span class="line">                Py_DECREF(inst);</span><br><span class="line">                inst = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Py_DECREF(res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (PyObject *)inst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>视频最后还讲了关于<code>bounded method</code>和<code>unbound method</code>的一些内容，简单来说，就是使用类取得的函数是<code>unbound</code>的，调用时需要显示传入对象，但对象调用自身方法时，已经绑定了对应的对象，它是一个<code>bounded</code>方法，无需再传入自身。尤其在使用一些装饰器时需要多加注意，想获取<code>bounded method</code>应当使用<code>inspece.get_members</code>之类的。</li>
<li><font color=red>对于<code>metaclass</code>创建类的过程仍未十分清晰，若有时间，仍需仔细看下</font></li>
</ul>
<h1 id="Lecture-9-Generators"><a href="#Lecture-9-Generators" class="headerlink" title="Lecture 9. Generators"></a>Lecture 9. Generators</h1><h3 id="1-生成器"><a href="#1-生成器" class="headerlink" title="1. 生成器"></a>1. 生成器</h3><ul>
<li>python测试代码(test.py)  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Counter</span>(<span class="params">low, high</span>):</span></span><br><span class="line">    current = low</span><br><span class="line">    <span class="keyword">while</span> current &lt;= high:</span><br><span class="line">        <span class="keyword">yield</span> current</span><br><span class="line">        current += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">c =  Counter(<span class="number">5</span>, <span class="number">7</span>)</span><br><span class="line"><span class="keyword">for</span> elt <span class="keyword">in</span> c:</span><br><span class="line">    print(elt)</span><br></pre></td></tr></table></figure>
  编译过后:  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">PS D:\CODE\Python-2.7.18&gt; python -m dis .\test.py</span><br><span class="line">             1 (<span class="string">&#x27;Counter&#x27;</span>)</span><br><span class="line">              4 MAKE_FUNCTION            0</span><br><span class="line">              6 STORE_NAME               0 (Counter)</span><br><span class="line"><span class="comment"># 创建Counter(5, 7)对象</span></span><br><span class="line">  7           8 LOAD_NAME                0 (Counter)</span><br><span class="line">             10 LOAD_CONST               2 (5)</span><br><span class="line">             12 LOAD_CONST               3 (7)</span><br><span class="line">             14 CALL_FUNCTION            2</span><br><span class="line">             16 STORE_NAME               1 (c)</span><br><span class="line"><span class="comment"># for 循环 </span></span><br><span class="line">  8          18 LOAD_NAME                1 (c)</span><br><span class="line">             20 GET_ITER</span><br><span class="line">        &gt;&gt;   22 FOR_ITER                12 (to 36)</span><br><span class="line">             24 STORE_NAME               2 (elt)</span><br><span class="line"></span><br><span class="line">  9          26 LOAD_NAME                3 (<span class="built_in">print</span>)</span><br><span class="line">             28 LOAD_NAME                2 (elt)</span><br><span class="line">             30 CALL_FUNCTION            1</span><br><span class="line">             32 POP_TOP</span><br><span class="line">             34 JUMP_ABSOLUTE           22</span><br><span class="line">        &gt;&gt;   36 LOAD_CONST               4 (None)</span><br><span class="line">             38 RETURN_VALUE</span><br><span class="line"><span class="comment"># Counter 函数的字节码 </span></span><br><span class="line">Disassembly of &lt;code object Counter at 0x000001DC7D029870, file <span class="string">&quot;.\test.py&quot;</span>, line 1&gt;:</span><br><span class="line">  2           0 LOAD_FAST                0 (low)</span><br><span class="line">              2 STORE_FAST               2 (current)</span><br><span class="line"></span><br><span class="line">  3     &gt;&gt;    4 LOAD_FAST                2 (current)</span><br><span class="line">              6 LOAD_FAST                1 (high)</span><br><span class="line">              8 COMPARE_OP               1 (&lt;=)</span><br><span class="line">             10 POP_JUMP_IF_FALSE       28</span><br><span class="line"></span><br><span class="line">  4          12 LOAD_FAST                2 (current)</span><br><span class="line">             14 YIELD_VALUE             <span class="comment"># yield对应的字节码，也是唯一区别之处</span></span><br><span class="line">             16 POP_TOP</span><br><span class="line"></span><br><span class="line">  5          18 LOAD_FAST                2 (current)</span><br><span class="line">             20 LOAD_CONST               1 (1)</span><br><span class="line">             22 INPLACE_ADD</span><br><span class="line">             24 STORE_FAST               2 (current)</span><br><span class="line">             26 JUMP_ABSOLUTE            4</span><br><span class="line">        &gt;&gt;   28 LOAD_CONST               0 (None)</span><br><span class="line">             30 RETURN_VALUE</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="2-YIELD-VALUE"><a href="#2-YIELD-VALUE" class="headerlink" title="2. YIELD_VALUE"></a>2. <code>YIELD_VALUE</code></h3><ul>
<li>生成器函数的字节码与普通函数的区别主要就是<code>YIELD_VALUE</code>，打会打断循环，函数调用等 原本的执行顺序（直接交付返回值）</li>
<li>在<code>ceval.c</code>中的具体执行的代码如下：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// switch... case YIELD_VALUE</span></span><br><span class="line">TARGET_NOARG(YIELD_VALUE)</span><br><span class="line">&#123;</span><br><span class="line">    retval = POP();         <span class="comment">// 每次执行这个YIELD_VALUE，会退出执行并返回栈顶的结果</span></span><br><span class="line">    f-&gt;f_stacktop = stack_pointer;</span><br><span class="line">    why = WHY_YIELD;</span><br><span class="line">    <span class="keyword">goto</span> fast_yield;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// fast_yield部分的代码如下</span></span><br><span class="line">fast_yield:</span><br><span class="line">    <span class="keyword">if</span> (tstate-&gt;use_tracing) &#123;      <span class="comment">// 应该时调试用的部分</span></span><br><span class="line">        <span class="keyword">if</span> (tstate-&gt;c_tracefunc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (why == WHY_RETURN || why == WHY_YIELD) &#123;</span><br><span class="line">                <span class="keyword">if</span> (call_trace(tstate-&gt;c_tracefunc,</span><br><span class="line">                            tstate-&gt;c_traceobj, f,</span><br><span class="line">                            PyTrace_RETURN, retval)) &#123;</span><br><span class="line">                    Py_XDECREF(retval);</span><br><span class="line">                    retval = <span class="literal">NULL</span>;</span><br><span class="line">                    why = WHY_EXCEPTION;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (why == WHY_EXCEPTION) &#123;</span><br><span class="line">                call_trace_protected(tstate-&gt;c_tracefunc,</span><br><span class="line">                                    tstate-&gt;c_traceobj, f,</span><br><span class="line">                                    PyTrace_RETURN, <span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tstate-&gt;c_profilefunc) &#123;</span><br><span class="line">            <span class="keyword">if</span> (why == WHY_EXCEPTION)</span><br><span class="line">                call_trace_protected(tstate-&gt;c_profilefunc,</span><br><span class="line">                                    tstate-&gt;c_profileobj, f,</span><br><span class="line">                                    PyTrace_RETURN, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (call_trace(tstate-&gt;c_profilefunc,</span><br><span class="line">                                tstate-&gt;c_profileobj, f,</span><br><span class="line">                                PyTrace_RETURN, retval)) &#123;</span><br><span class="line">                Py_XDECREF(retval);</span><br><span class="line">                retval = <span class="literal">NULL</span>;</span><br><span class="line">                why = WHY_EXCEPTION;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tstate-&gt;frame-&gt;f_exc_type != <span class="literal">NULL</span>)</span><br><span class="line">        reset_exc_info(tstate);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        assert(tstate-&gt;frame-&gt;f_exc_value == <span class="literal">NULL</span>);</span><br><span class="line">        assert(tstate-&gt;frame-&gt;f_exc_traceback == <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//... 其他几个goto的标志</span></span><br><span class="line"><span class="keyword">return</span> retval;      <span class="comment">// 返回结果</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="3-genobject生成器对象"><a href="#3-genobject生成器对象" class="headerlink" title="3. genobject生成器对象"></a>3. <code>genobject</code>生成器对象</h3><ul>
<li>cpython 的结构体定义  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    PyObject_HEAD</span><br><span class="line">    <span class="comment">/* The gi_ prefix is intended to remind of generator-iterator. */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Note: gi_frame can be NULL if the generator is &quot;finished&quot; */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">frame</span> *<span class="title">gi_frame</span>;</span>            <span class="comment">// 函数运行时的frame，只要不为空，就可以一直被运行（not finished）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* True if generator is being executed. */</span></span><br><span class="line">    <span class="keyword">int</span> gi_running;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* The code object backing the generator */</span></span><br><span class="line">    PyObject *gi_code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* List of weak reference. */</span></span><br><span class="line">    PyObject *gi_weakreflist;</span><br><span class="line">&#125; PyGenObject;</span><br></pre></td></tr></table></figure></li>
<li>每当想获取生成器对象<code>gen</code>的迭代器时<code>gen-&gt;tp_iter</code>，生成器对象会把自己返回过去，当调用<code>gen.next</code>方法<code>gen-&gt;tp_iternext</code>的时候，其实执行的是<code>gen_iternext</code>方法，因此生成器对象可以非常自然地表现地像是一个迭代器和可迭代对象  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">PyTypeObject PyGen_Type = &#123;</span><br><span class="line">    PyVarObject_HEAD_INIT(&amp;PyType_Type, <span class="number">0</span>)</span><br><span class="line">    <span class="string">&quot;generator&quot;</span>,                                <span class="comment">/* tp_name */</span></span><br><span class="line">    <span class="keyword">sizeof</span>(PyGenObject),                        <span class="comment">/* tp_basicsize */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_itemsize */</span></span><br><span class="line">    <span class="comment">/* methods */</span></span><br><span class="line">    (destructor)gen_dealloc,                    <span class="comment">/* tp_dealloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_print */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_getattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_compare */</span></span><br><span class="line">    (reprfunc)gen_repr,                         <span class="comment">/* tp_repr */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_number */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_sequence */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_mapping */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_hash */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_call */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_str */</span></span><br><span class="line">    PyObject_GenericGetAttr,                    <span class="comment">/* tp_getattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_setattro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_as_buffer */</span></span><br><span class="line">    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,<span class="comment">/* tp_flags */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_doc */</span></span><br><span class="line">    (traverseproc)gen_traverse,                 <span class="comment">/* tp_traverse */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_clear */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_richcompare */</span></span><br><span class="line">    offsetof(PyGenObject, gi_weakreflist),      <span class="comment">/* tp_weaklistoffset */</span></span><br><span class="line">    PyObject_SelfIter,                          <span class="comment">/* tp_iter */</span>       <span class="comment">// 生成器的迭代器就是它自己</span></span><br><span class="line">    (iternextfunc)gen_iternext,                 <span class="comment">/* tp_iternext */</span>   <span class="comment">// 生成器的next方法执行的是`gen_iternext`函数</span></span><br><span class="line">    gen_methods,                                <span class="comment">/* tp_methods */</span></span><br><span class="line">    gen_memberlist,                             <span class="comment">/* tp_members */</span></span><br><span class="line">    gen_getsetlist,                             <span class="comment">/* tp_getset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_base */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dict */</span></span><br><span class="line"></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_get */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_descr_set */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_dictoffset */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_init */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_alloc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_new */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_free */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_is_gc */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_bases */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_mro */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_cache */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_subclasses */</span></span><br><span class="line">    <span class="number">0</span>,                                          <span class="comment">/* tp_weaklist */</span></span><br><span class="line">    gen_del,                                    <span class="comment">/* tp_del */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>像上述的<code>gen_iternext</code>，<code>gen_send</code>等函数，在<code>genobject.c</code>中，执行的都是<code>gen_send_ex</code>函数，这个函数，就是每次驱动生成器推进的主要逻辑所在，具体的代码如下：  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> PyObject *</span><br><span class="line">gen_send_ex(PyGenObject *gen, PyObject *arg, <span class="keyword">int</span> exc)</span><br><span class="line">&#123;</span><br><span class="line">    PyThreadState *tstate = PyThreadState_GET();</span><br><span class="line">    PyFrameObject *f = gen-&gt;gi_frame;           <span class="comment">// 取出上一次执行过程中的frame</span></span><br><span class="line">    PyObject *result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (gen-&gt;gi_running) &#123;                      <span class="comment">// 如果生成器已经在执行过程中了，就会抛异常(大概是在生成器执行过程中，又把自己执行了一遍)</span></span><br><span class="line">        PyErr_SetString(PyExc_ValueError,</span><br><span class="line">                        <span class="string">&quot;generator already executing&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (f==<span class="literal">NULL</span> || f-&gt;f_stacktop == <span class="literal">NULL</span>) &#123;         <span class="comment">// 当生成器的frame为空时，就抛出StopInteration</span></span><br><span class="line">        <span class="comment">/* Only set exception if called from send() */</span></span><br><span class="line">        <span class="keyword">if</span> (arg &amp;&amp; !exc)</span><br><span class="line">            PyErr_SetNone(PyExc_StopIteration);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (f-&gt;f_lasti == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arg &amp;&amp; arg != Py_None) &#123;</span><br><span class="line">            PyErr_SetString(PyExc_TypeError,</span><br><span class="line">                            <span class="string">&quot;can&#x27;t send non-None value to a &quot;</span></span><br><span class="line">                            <span class="string">&quot;just-started generator&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* Push arg onto the frame&#x27;s value stack */</span></span><br><span class="line">        result = arg ? arg : Py_None;       <span class="comment">// 如果send方法没有传入参数，就置为None</span></span><br><span class="line">        Py_INCREF(result);</span><br><span class="line">        *(f-&gt;f_stacktop++) = result;        <span class="comment">// 把参数压入栈顶</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Generators always return to their most recent caller, not</span></span><br><span class="line"><span class="comment">    * necessarily their creator. */</span></span><br><span class="line">    f-&gt;f_tstate = tstate;</span><br><span class="line">    Py_XINCREF(tstate-&gt;frame);</span><br><span class="line">    assert(f-&gt;f_back == <span class="literal">NULL</span>);</span><br><span class="line">    f-&gt;f_back = tstate-&gt;frame;</span><br><span class="line"></span><br><span class="line">    gen-&gt;gi_running = <span class="number">1</span>;            <span class="comment">// 讲正在运行的标记置为1</span></span><br><span class="line">    result = PyEval_EvalFrameEx(f, exc);        <span class="comment">// 重新执行生成器中的代码，并取出结果(由上面分析的结果看，他会在`YIELD_VALUE`部分返回结果，不会无止境的执行下去)</span></span><br><span class="line">    gen-&gt;gi_running = <span class="number">0</span>;            <span class="comment">// 重置为0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Don&#x27;t keep the reference to f_back any longer than necessary.  It</span></span><br><span class="line"><span class="comment">    * may keep a chain of frames alive or it could create a reference</span></span><br><span class="line"><span class="comment">    * cycle. */</span></span><br><span class="line">    assert(f-&gt;f_back == tstate-&gt;frame);</span><br><span class="line">    Py_CLEAR(f-&gt;f_back);</span><br><span class="line">    <span class="comment">/* Clear the borrowed reference to the thread state */</span></span><br><span class="line">    f-&gt;f_tstate = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If the generator just returned (as opposed to yielding), signal</span></span><br><span class="line"><span class="comment">    * that the generator is exhausted. */</span></span><br><span class="line">    <span class="keyword">if</span> (result == Py_None &amp;&amp; f-&gt;f_stacktop == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Py_DECREF(result);</span><br><span class="line">        result = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">/* Set exception if not called by gen_iternext() */</span></span><br><span class="line">        <span class="keyword">if</span> (arg)</span><br><span class="line">            PyErr_SetNone(PyExc_StopIteration);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!result || f-&gt;f_stacktop == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">/* generator can&#x27;t be rerun, so release the frame */</span></span><br><span class="line">        Py_DECREF(f);</span><br><span class="line">        gen-&gt;gi_frame = <span class="literal">NULL</span>;       <span class="comment">// 生成器是一次性的，本质上就是这个frame在不断地被打断和启动</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2021/04/07/CPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" data-id="cktvhfla3001mji9shkoqbmbw" data-title="CPython学习笔记" class="article-share-link">Compartir</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python%E7%AC%94%E8%AE%B0/" rel="tag">python笔记</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/05/19/%E7%BD%91%E7%BB%9C%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">上一篇</strong>
      <div class="article-nav-title">
        
          《网络多人游戏架构与编程》笔记
        
      </div>
    </a>
  
  
    <a href="/2020/12/13/%E6%B5%81%E7%95%85%E7%9A%84python/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">下一篇</strong>
      <div class="article-nav-title">《流畅的python》笔记</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/CS%E7%AC%94%E8%AE%B0/" rel="tag">CS笔记</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/python%E7%AC%94%E8%AE%B0/" rel="tag">python笔记</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%B6%E4%BB%96/" rel="tag">其他</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A9%E6%96%87%E7%89%A9%E7%90%86%E5%AD%A6%E7%AC%94%E8%AE%B0/" rel="tag">天文物理学笔记</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" rel="tag">数据库</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/" rel="tag">服务端开发</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/" rel="tag">游戏开发</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Nube de Tags</h3>
    <div class="widget tagcloud">
      <a href="/tags/CS%E7%AC%94%E8%AE%B0/" style="font-size: 16.67px;">CS笔记</a> <a href="/tags/python%E7%AC%94%E8%AE%B0/" style="font-size: 13.33px;">python笔记</a> <a href="/tags/%E5%85%B6%E4%BB%96/" style="font-size: 10px;">其他</a> <a href="/tags/%E5%A4%A9%E6%96%87%E7%89%A9%E7%90%86%E5%AD%A6%E7%AC%94%E8%AE%B0/" style="font-size: 20px;">天文物理学笔记</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" style="font-size: 10px;">数据库</a> <a href="/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91/" style="font-size: 10px;">服务端开发</a> <a href="/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/" style="font-size: 10px;">游戏开发</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archivos</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/12/">December 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/10/">October 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Posts recientes</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/08/07/mongo%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">mongo学习笔记</a>
          </li>
        
          <li>
            <a href="/2021/07/05/%E8%A2%AB%E8%AE%A8%E5%8E%8C%E7%9A%84%E5%8B%87%E6%B0%94/">《被讨厌的勇气》笔记</a>
          </li>
        
          <li>
            <a href="/2021/05/19/%E7%BD%91%E7%BB%9C%E5%A4%9A%E4%BA%BA%E6%B8%B8%E6%88%8F%E6%9E%B6%E6%9E%84%E4%B8%8E%E7%BC%96%E7%A8%8B/">《网络多人游戏架构与编程》笔记</a>
          </li>
        
          <li>
            <a href="/2021/04/07/CPython%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">CPython学习笔记</a>
          </li>
        
          <li>
            <a href="/2020/12/13/%E6%B5%81%E7%95%85%E7%9A%84python/">《流畅的python》笔记</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="footer-outer">
    <div id="footer-info" class="inner">
      &copy; 2021 WenZhou<br>
      Construido por <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>






<!-- 处理mermaid流程图 -->

  <script src='https://unpkg.com/mermaid@7.1.2/dist/mermaid.min.js'></script>
  <script>
    if (window.mermaid) {
      mermaid.initialize({theme: 'base'});
    }
  </script>

  </div>
</body>
</html>